[
    {
        "label": "runpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "runpy",
        "description": "runpy",
        "detail": "runpy",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "heavi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heavi",
        "description": "heavi",
        "detail": "heavi",
        "documentation": {}
    },
    {
        "label": "heavi.lib.optim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heavi.lib.optim",
        "description": "heavi.lib.optim",
        "detail": "heavi.lib.optim",
        "documentation": {}
    },
    {
        "label": "minimize",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "differential_evolution",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "dual_annealing",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "direct",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "shgo",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "minimize",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "differential_evolution",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "dual_annealing",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "direct",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "shgo",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "minimize",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "differential_evolution",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "dual_annealing",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "direct",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "shgo",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "minimize",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "differential_evolution",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "dual_annealing",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "direct",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "shgo",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "root_scalar",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "fsolve",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "differential_evolution",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "minimize",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "brute",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "differential_evolution",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "fsolve",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "root_scalar",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "test_network",
        "importPath": "valid_test",
        "description": "valid_test",
        "isExtraImport": true,
        "detail": "valid_test",
        "documentation": {}
    },
    {
        "label": "test_network",
        "importPath": "valid_test",
        "description": "valid_test",
        "isExtraImport": true,
        "detail": "valid_test",
        "documentation": {}
    },
    {
        "label": "test_network",
        "importPath": "valid_test",
        "description": "valid_test",
        "isExtraImport": true,
        "detail": "valid_test",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "product",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "product",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "Drawing",
        "importPath": "schemdraw",
        "description": "schemdraw",
        "isExtraImport": true,
        "detail": "schemdraw",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "schemdraw",
        "description": "schemdraw",
        "isExtraImport": true,
        "detail": "schemdraw",
        "documentation": {}
    },
    {
        "label": "Drawing",
        "importPath": "schemdraw",
        "description": "schemdraw",
        "isExtraImport": true,
        "detail": "schemdraw",
        "documentation": {}
    },
    {
        "label": "elements",
        "importPath": "schemdraw",
        "description": "schemdraw",
        "isExtraImport": true,
        "detail": "schemdraw",
        "documentation": {}
    },
    {
        "label": "schemdraw.elements",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "schemdraw.elements",
        "description": "schemdraw.elements",
        "detail": "schemdraw.elements",
        "documentation": {}
    },
    {
        "label": "smd",
        "importPath": "heavi.lib",
        "description": "heavi.lib",
        "isExtraImport": true,
        "detail": "heavi.lib",
        "documentation": {}
    },
    {
        "label": "pcb",
        "importPath": "heavi.lib",
        "description": "heavi.lib",
        "isExtraImport": true,
        "detail": "heavi.lib",
        "documentation": {}
    },
    {
        "label": "mc",
        "importPath": "heavi.lib",
        "description": "heavi.lib",
        "isExtraImport": true,
        "detail": "heavi.lib",
        "documentation": {}
    },
    {
        "label": "pcb",
        "importPath": "heavi.lib",
        "description": "heavi.lib",
        "isExtraImport": true,
        "detail": "heavi.lib",
        "documentation": {}
    },
    {
        "label": "nonlinear",
        "importPath": "heavi.lib",
        "description": "heavi.lib",
        "isExtraImport": true,
        "detail": "heavi.lib",
        "documentation": {}
    },
    {
        "label": "lumped",
        "importPath": "heavi.lib",
        "description": "heavi.lib",
        "isExtraImport": true,
        "detail": "heavi.lib",
        "documentation": {}
    },
    {
        "label": "smd",
        "importPath": "heavi.lib",
        "description": "heavi.lib",
        "isExtraImport": true,
        "detail": "heavi.lib",
        "documentation": {}
    },
    {
        "label": "lumped",
        "importPath": "heavi.lib",
        "description": "heavi.lib",
        "isExtraImport": true,
        "detail": "heavi.lib",
        "documentation": {}
    },
    {
        "label": "optim",
        "importPath": "heavi.lib",
        "description": "heavi.lib",
        "isExtraImport": true,
        "detail": "heavi.lib",
        "documentation": {}
    },
    {
        "label": "analyse_sparameter",
        "importPath": "heavi.stochastic",
        "description": "heavi.stochastic",
        "isExtraImport": true,
        "detail": "heavi.stochastic",
        "documentation": {}
    },
    {
        "label": "njit",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "njit",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "prange",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "c16",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "i8",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "f8",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "njit",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "prange",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "c16",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "i8",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "f8",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "sympy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sympy",
        "description": "sympy",
        "detail": "sympy",
        "documentation": {}
    },
    {
        "label": "TR0",
        "importPath": "sympy.simplify.fu",
        "description": "sympy.simplify.fu",
        "isExtraImport": true,
        "detail": "sympy.simplify.fu",
        "documentation": {}
    },
    {
        "label": "TR8",
        "importPath": "sympy.simplify.fu",
        "description": "sympy.simplify.fu",
        "isExtraImport": true,
        "detail": "sympy.simplify.fu",
        "documentation": {}
    },
    {
        "label": "TR0",
        "importPath": "sympy.simplify.fu",
        "description": "sympy.simplify.fu",
        "isExtraImport": true,
        "detail": "sympy.simplify.fu",
        "documentation": {}
    },
    {
        "label": "TR8",
        "importPath": "sympy.simplify.fu",
        "description": "sympy.simplify.fu",
        "isExtraImport": true,
        "detail": "sympy.simplify.fu",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "matplotlib.ticker",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.ticker",
        "description": "matplotlib.ticker",
        "detail": "matplotlib.ticker",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "numba_progress",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numba_progress",
        "description": "numba_progress",
        "detail": "numba_progress",
        "documentation": {}
    },
    {
        "label": "ProgressBarType",
        "importPath": "numba_progress.progress",
        "description": "numba_progress.progress",
        "isExtraImport": true,
        "detail": "numba_progress.progress",
        "documentation": {}
    },
    {
        "label": "ProgressBarType",
        "importPath": "numba_progress.progress",
        "description": "numba_progress.progress",
        "isExtraImport": true,
        "detail": "numba_progress.progress",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "Value",
        "importPath": "multiprocessing.sharedctypes",
        "description": "multiprocessing.sharedctypes",
        "isExtraImport": true,
        "detail": "multiprocessing.sharedctypes",
        "documentation": {}
    },
    {
        "label": "random",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "rfcircuit",
        "description": "rfcircuit",
        "isExtraImport": true,
        "detail": "rfcircuit",
        "documentation": {}
    },
    {
        "label": "NonLinearComponent",
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "isExtraImport": true,
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "NonLinearComponent",
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "isExtraImport": true,
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "SpiceLibrary",
        "importPath": "heavi.lib.spice",
        "description": "heavi.lib.spice",
        "isExtraImport": true,
        "detail": "heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "import_spice_library_directory",
        "importPath": "heavi.lib.spice",
        "description": "heavi.lib.spice",
        "isExtraImport": true,
        "detail": "heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "plot_s_parameters",
        "importPath": "build.lib.heavi.graphing",
        "description": "build.lib.heavi.graphing",
        "isExtraImport": true,
        "detail": "build.lib.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "testlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "testlib",
        "description": "testlib",
        "detail": "testlib",
        "documentation": {}
    },
    {
        "label": "FileBasedNPort",
        "importPath": "heavi.lib.touchstone",
        "description": "heavi.lib.touchstone",
        "isExtraImport": true,
        "detail": "heavi.lib.touchstone",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "scipy.interpolate",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "interp1d",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "interpn",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "RegularGridInterpolator",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "BaseTwoPort",
        "importPath": "heavi.lib.libgen",
        "description": "heavi.lib.libgen",
        "isExtraImport": true,
        "detail": "heavi.lib.libgen",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "heavi.rfcircuit",
        "description": "heavi.rfcircuit",
        "isExtraImport": true,
        "detail": "heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len(\"bin\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"heavi\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.10/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "base = bin_dir[: -len(\"bin\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"heavi\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.10/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"heavi\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.10/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"heavi\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.10/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV_PROMPT\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV_PROMPT\"] = \"heavi\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.10/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in \"../lib/python3.10/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "run_matrix",
        "kind": 2,
        "importPath": "_old_python_files.all_filters_test",
        "description": "_old_python_files.all_filters_test",
        "peekOfCode": "def run_matrix(name: str, LC: np.ndarray):\n    tot_nodes = LC.shape[0]\n    n_extra = tot_nodes-3\n    if n_extra < 1:\n        raise ValueError('Only works for 1 extra node')\n    M = hv.Model(suppress_loadbar=True)\n    O = opt.Optimiser(M)\n    p1 = M.new_port(50)\n    p2 = M.new_port(50)\n    nodes = [M.gnd, p1] + [M.node() for _ in range(n_extra)] + [p2,]",
        "detail": "_old_python_files.all_filters_test",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "_old_python_files.all_filters_test",
        "description": "_old_python_files.all_filters_test",
        "peekOfCode": "N = 1 + 3\nids = [(i,j) for i in range(N) for j in range(N) if i!=j]\nfrom itertools import permutations\ncompleted = set()\nctr = 0\nfor options in permutations(ids, 7):\n    ctr+=1\n    if ctr < 0:\n        continue\n    net = np.zeros((N,N))",
        "detail": "_old_python_files.all_filters_test",
        "documentation": {}
    },
    {
        "label": "ids",
        "kind": 5,
        "importPath": "_old_python_files.all_filters_test",
        "description": "_old_python_files.all_filters_test",
        "peekOfCode": "ids = [(i,j) for i in range(N) for j in range(N) if i!=j]\nfrom itertools import permutations\ncompleted = set()\nctr = 0\nfor options in permutations(ids, 7):\n    ctr+=1\n    if ctr < 0:\n        continue\n    net = np.zeros((N,N))\n    tupnet = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]",
        "detail": "_old_python_files.all_filters_test",
        "documentation": {}
    },
    {
        "label": "completed",
        "kind": 5,
        "importPath": "_old_python_files.all_filters_test",
        "description": "_old_python_files.all_filters_test",
        "peekOfCode": "completed = set()\nctr = 0\nfor options in permutations(ids, 7):\n    ctr+=1\n    if ctr < 0:\n        continue\n    net = np.zeros((N,N))\n    tupnet = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]\n    for (i,j) in options:\n        net[i,j] = 1",
        "detail": "_old_python_files.all_filters_test",
        "documentation": {}
    },
    {
        "label": "ctr",
        "kind": 5,
        "importPath": "_old_python_files.all_filters_test",
        "description": "_old_python_files.all_filters_test",
        "peekOfCode": "ctr = 0\nfor options in permutations(ids, 7):\n    ctr+=1\n    if ctr < 0:\n        continue\n    net = np.zeros((N,N))\n    tupnet = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]\n    for (i,j) in options:\n        net[i,j] = 1\n        tupnet[i][j] = 1",
        "detail": "_old_python_files.all_filters_test",
        "documentation": {}
    },
    {
        "label": "run_matrix",
        "kind": 2,
        "importPath": "_old_python_files.arbitrary_filter_generator_test",
        "description": "_old_python_files.arbitrary_filter_generator_test",
        "peekOfCode": "def run_matrix(name: str, LC: np.ndarray, vallimit: float, spec_levels: list[tuple]):\n    tot_nodes = LC.shape[0]\n    n_extra = tot_nodes-3\n    if n_extra < 1:\n        raise ValueError('Only works for 1 extra node')\n    M = hv.Model(suppress_loadbar=True)\n    O = opt.Optimiser(M)\n    p1 = M.new_port(50)\n    p2 = M.new_port(50)\n    nodes = [M.gnd, p1] + [M.node() for _ in range(n_extra)] + [p2,]",
        "detail": "_old_python_files.arbitrary_filter_generator_test",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "_old_python_files.arbitrary_filter_generator_test",
        "description": "_old_python_files.arbitrary_filter_generator_test",
        "peekOfCode": "N = 2 + 3\nids = [(i,j) for i in range(N) for j in range(N) if i!=j]\nspecs = [\n    (3e9, 3.5e9, 11, (1,1), -20),\n    (3.7e9, 6e9, 11, (2,1), -20),\n]\nN_components = 9\ncompleted = set()\nctr = 0\ninitial = 2",
        "detail": "_old_python_files.arbitrary_filter_generator_test",
        "documentation": {}
    },
    {
        "label": "ids",
        "kind": 5,
        "importPath": "_old_python_files.arbitrary_filter_generator_test",
        "description": "_old_python_files.arbitrary_filter_generator_test",
        "peekOfCode": "ids = [(i,j) for i in range(N) for j in range(N) if i!=j]\nspecs = [\n    (3e9, 3.5e9, 11, (1,1), -20),\n    (3.7e9, 6e9, 11, (2,1), -20),\n]\nN_components = 9\ncompleted = set()\nctr = 0\ninitial = 2\nfor options in permutations(ids, N_components):",
        "detail": "_old_python_files.arbitrary_filter_generator_test",
        "documentation": {}
    },
    {
        "label": "specs",
        "kind": 5,
        "importPath": "_old_python_files.arbitrary_filter_generator_test",
        "description": "_old_python_files.arbitrary_filter_generator_test",
        "peekOfCode": "specs = [\n    (3e9, 3.5e9, 11, (1,1), -20),\n    (3.7e9, 6e9, 11, (2,1), -20),\n]\nN_components = 9\ncompleted = set()\nctr = 0\ninitial = 2\nfor options in permutations(ids, N_components):\n    ctr+=1",
        "detail": "_old_python_files.arbitrary_filter_generator_test",
        "documentation": {}
    },
    {
        "label": "N_components",
        "kind": 5,
        "importPath": "_old_python_files.arbitrary_filter_generator_test",
        "description": "_old_python_files.arbitrary_filter_generator_test",
        "peekOfCode": "N_components = 9\ncompleted = set()\nctr = 0\ninitial = 2\nfor options in permutations(ids, N_components):\n    ctr+=1\n    net = np.zeros((N,N))\n    tupnet = [[0 for _ in range(N)] for _ in range(N)]\n    for (i,j) in options:\n        net[i,j] = 1",
        "detail": "_old_python_files.arbitrary_filter_generator_test",
        "documentation": {}
    },
    {
        "label": "completed",
        "kind": 5,
        "importPath": "_old_python_files.arbitrary_filter_generator_test",
        "description": "_old_python_files.arbitrary_filter_generator_test",
        "peekOfCode": "completed = set()\nctr = 0\ninitial = 2\nfor options in permutations(ids, N_components):\n    ctr+=1\n    net = np.zeros((N,N))\n    tupnet = [[0 for _ in range(N)] for _ in range(N)]\n    for (i,j) in options:\n        net[i,j] = 1\n        tupnet[i][j] = 1",
        "detail": "_old_python_files.arbitrary_filter_generator_test",
        "documentation": {}
    },
    {
        "label": "ctr",
        "kind": 5,
        "importPath": "_old_python_files.arbitrary_filter_generator_test",
        "description": "_old_python_files.arbitrary_filter_generator_test",
        "peekOfCode": "ctr = 0\ninitial = 2\nfor options in permutations(ids, N_components):\n    ctr+=1\n    net = np.zeros((N,N))\n    tupnet = [[0 for _ in range(N)] for _ in range(N)]\n    for (i,j) in options:\n        net[i,j] = 1\n        tupnet[i][j] = 1\n    tupnet = tuple([tuple(x) for x in tupnet])",
        "detail": "_old_python_files.arbitrary_filter_generator_test",
        "documentation": {}
    },
    {
        "label": "initial",
        "kind": 5,
        "importPath": "_old_python_files.arbitrary_filter_generator_test",
        "description": "_old_python_files.arbitrary_filter_generator_test",
        "peekOfCode": "initial = 2\nfor options in permutations(ids, N_components):\n    ctr+=1\n    net = np.zeros((N,N))\n    tupnet = [[0 for _ in range(N)] for _ in range(N)]\n    for (i,j) in options:\n        net[i,j] = 1\n        tupnet[i][j] = 1\n    tupnet = tuple([tuple(x) for x in tupnet])\n    if tupnet not in completed:",
        "detail": "_old_python_files.arbitrary_filter_generator_test",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "f = hv.frange(1.8e9, 2.3e9, 2001)\n# Model with two cascaded filters\nmodel = hv.Model(suppress_loadbar=True)\np1 = model.new_port(50)\np2 = model.new_port(50)\nn1 = model.node()\nn2 = model.node()\nmodel.filters.cauer_filter(model.gnd, p1, n1, 2e9, 100e6, 5, 0.05, \n                           hv.FilterType.CHEBYCHEV, \n                           type=hv.BandType.BANDPASS, ",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "model = hv.Model(suppress_loadbar=True)\np1 = model.new_port(50)\np2 = model.new_port(50)\nn1 = model.node()\nn2 = model.node()\nmodel.filters.cauer_filter(model.gnd, p1, n1, 2e9, 100e6, 5, 0.05, \n                           hv.FilterType.CHEBYCHEV, \n                           type=hv.BandType.BANDPASS, \n                           chebychev_correction=True)\nmodel.filters.cauer_filter(model.gnd, n2, p2, 2.1e9, 100e6, 3, 0.05, ",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "p1 = model.new_port(50)\np2 = model.new_port(50)\nn1 = model.node()\nn2 = model.node()\nmodel.filters.cauer_filter(model.gnd, p1, n1, 2e9, 100e6, 5, 0.05, \n                           hv.FilterType.CHEBYCHEV, \n                           type=hv.BandType.BANDPASS, \n                           chebychev_correction=True)\nmodel.filters.cauer_filter(model.gnd, n2, p2, 2.1e9, 100e6, 3, 0.05, \n                           hv.FilterType.CHEBYCHEV, ",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "p2 = model.new_port(50)\nn1 = model.node()\nn2 = model.node()\nmodel.filters.cauer_filter(model.gnd, p1, n1, 2e9, 100e6, 5, 0.05, \n                           hv.FilterType.CHEBYCHEV, \n                           type=hv.BandType.BANDPASS, \n                           chebychev_correction=True)\nmodel.filters.cauer_filter(model.gnd, n2, p2, 2.1e9, 100e6, 3, 0.05, \n                           hv.FilterType.CHEBYCHEV, \n                           type=hv.BandType.BANDSTOP, ",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "n1 = model.node()\nn2 = model.node()\nmodel.filters.cauer_filter(model.gnd, p1, n1, 2e9, 100e6, 5, 0.05, \n                           hv.FilterType.CHEBYCHEV, \n                           type=hv.BandType.BANDPASS, \n                           chebychev_correction=True)\nmodel.filters.cauer_filter(model.gnd, n2, p2, 2.1e9, 100e6, 3, 0.05, \n                           hv.FilterType.CHEBYCHEV, \n                           type=hv.BandType.BANDSTOP, \n                           cauer_type=hv.CauerType.TYPE1,",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "n2 = model.node()\nmodel.filters.cauer_filter(model.gnd, p1, n1, 2e9, 100e6, 5, 0.05, \n                           hv.FilterType.CHEBYCHEV, \n                           type=hv.BandType.BANDPASS, \n                           chebychev_correction=True)\nmodel.filters.cauer_filter(model.gnd, n2, p2, 2.1e9, 100e6, 3, 0.05, \n                           hv.FilterType.CHEBYCHEV, \n                           type=hv.BandType.BANDSTOP, \n                           cauer_type=hv.CauerType.TYPE1,\n                           chebychev_correction=True)",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "S = model.run_sparameter_analysis(f)\n# Model with one filter\nmodel2 = hv.Model(suppress_loadbar=True)\np12 = model2.new_port(50)\np22 = model2.new_port(50)\nmodel2.filters.cauer_filter(model2.gnd, p12, p22, 2.1e9, 100e6, 5, 0.05, \n                            hv.FilterType.CHEBYCHEV, \n                            type=hv.BandType.BANDSTOP, \n                            chebychev_correction=True)\nS2 = model2.run(f)",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "model2",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "model2 = hv.Model(suppress_loadbar=True)\np12 = model2.new_port(50)\np22 = model2.new_port(50)\nmodel2.filters.cauer_filter(model2.gnd, p12, p22, 2.1e9, 100e6, 5, 0.05, \n                            hv.FilterType.CHEBYCHEV, \n                            type=hv.BandType.BANDSTOP, \n                            chebychev_correction=True)\nS2 = model2.run(f)\n# Model with one filter\nmodel3 = hv.Model(suppress_loadbar=True)",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "p12",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "p12 = model2.new_port(50)\np22 = model2.new_port(50)\nmodel2.filters.cauer_filter(model2.gnd, p12, p22, 2.1e9, 100e6, 5, 0.05, \n                            hv.FilterType.CHEBYCHEV, \n                            type=hv.BandType.BANDSTOP, \n                            chebychev_correction=True)\nS2 = model2.run(f)\n# Model with one filter\nmodel3 = hv.Model(suppress_loadbar=True)\np13 = model3.new_port(50)",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "p22",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "p22 = model2.new_port(50)\nmodel2.filters.cauer_filter(model2.gnd, p12, p22, 2.1e9, 100e6, 5, 0.05, \n                            hv.FilterType.CHEBYCHEV, \n                            type=hv.BandType.BANDSTOP, \n                            chebychev_correction=True)\nS2 = model2.run(f)\n# Model with one filter\nmodel3 = hv.Model(suppress_loadbar=True)\np13 = model3.new_port(50)\np23 = model3.new_port(50)",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "S2",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "S2 = model2.run(f)\n# Model with one filter\nmodel3 = hv.Model(suppress_loadbar=True)\np13 = model3.new_port(50)\np23 = model3.new_port(50)\nmodel3.filters.cauer_filter(model3.gnd, p13, p23, 2.0e9, 100e6, 5, 0.05, \n                            hv.FilterType.CHEBYCHEV, \n                            type=hv.BandType.BANDPASS, \n                            chebychev_correction=True)\nS3 = model3.run(f)",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "model3",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "model3 = hv.Model(suppress_loadbar=True)\np13 = model3.new_port(50)\np23 = model3.new_port(50)\nmodel3.filters.cauer_filter(model3.gnd, p13, p23, 2.0e9, 100e6, 5, 0.05, \n                            hv.FilterType.CHEBYCHEV, \n                            type=hv.BandType.BANDPASS, \n                            chebychev_correction=True)\nS3 = model3.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21])\n# Plotting the data",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "p13",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "p13 = model3.new_port(50)\np23 = model3.new_port(50)\nmodel3.filters.cauer_filter(model3.gnd, p13, p23, 2.0e9, 100e6, 5, 0.05, \n                            hv.FilterType.CHEBYCHEV, \n                            type=hv.BandType.BANDPASS, \n                            chebychev_correction=True)\nS3 = model3.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21])\n# Plotting the data\nhv.plot_s_parameters(f, [S.S11, S.S21, S2.S11, S3.S11, S2.S21, S3.S21], ",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "p23",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "p23 = model3.new_port(50)\nmodel3.filters.cauer_filter(model3.gnd, p13, p23, 2.0e9, 100e6, 5, 0.05, \n                            hv.FilterType.CHEBYCHEV, \n                            type=hv.BandType.BANDPASS, \n                            chebychev_correction=True)\nS3 = model3.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21])\n# Plotting the data\nhv.plot_s_parameters(f, [S.S11, S.S21, S2.S11, S3.S11, S2.S21, S3.S21], \n                     labels=[\"Dual S11\", \"Dual S21\", \"Single S11\", \"Single S11\",\"Single SS1\", \"Single SS1\"], ",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "S3",
        "kind": 5,
        "importPath": "_old_python_files.bandstop_test",
        "description": "_old_python_files.bandstop_test",
        "peekOfCode": "S3 = model3.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21])\n# Plotting the data\nhv.plot_s_parameters(f, [S.S11, S.S21, S2.S11, S3.S11, S2.S21, S3.S21], \n                     labels=[\"Dual S11\", \"Dual S21\", \"Single S11\", \"Single S11\",\"Single SS1\", \"Single SS1\"], \n                     linestyles=[\"-\",\":\",\"--\",\"--\",\":\",\":\"], \n                     colorcycle=[0,0,1,2,1,2],\n                     dblim=[-40,5])",
        "detail": "_old_python_files.bandstop_test",
        "documentation": {}
    },
    {
        "label": "L",
        "kind": 5,
        "importPath": "_old_python_files.circuit_draw_test",
        "description": "_old_python_files.circuit_draw_test",
        "peekOfCode": "L = 3\ndL = 1\nconfig(lw=2)\nwith Drawing() as d:\n    emt.style(emt.STYLE_IEC)\n    d.config(unit=L)\n    emt.SourceSin().up()\n    d.move(dy=-L)\n    emt.Ground()\n    d.move(dy=L)",
        "detail": "_old_python_files.circuit_draw_test",
        "documentation": {}
    },
    {
        "label": "dL",
        "kind": 5,
        "importPath": "_old_python_files.circuit_draw_test",
        "description": "_old_python_files.circuit_draw_test",
        "peekOfCode": "dL = 1\nconfig(lw=2)\nwith Drawing() as d:\n    emt.style(emt.STYLE_IEC)\n    d.config(unit=L)\n    emt.SourceSin().up()\n    d.move(dy=-L)\n    emt.Ground()\n    d.move(dy=L)\n    emt.Resistor().right().label('50')",
        "detail": "_old_python_files.circuit_draw_test",
        "documentation": {}
    },
    {
        "label": "strC",
        "kind": 2,
        "importPath": "_old_python_files.draw_circuits_test",
        "description": "_old_python_files.draw_circuits_test",
        "peekOfCode": "def strC(val):\n    print(val)\n    return f'{float(val)/p:.2f}pF'\ndef strL(val):\n    print(val)\n    return f'{float(val)/n:.2f}nH'\ni = 1\nfor name, circuit,values in filters:\n    print(values)\n    components = [int(float(x)) for x in circuit.replace('[','').replace(']','').split(' ') if x]",
        "detail": "_old_python_files.draw_circuits_test",
        "documentation": {}
    },
    {
        "label": "strL",
        "kind": 2,
        "importPath": "_old_python_files.draw_circuits_test",
        "description": "_old_python_files.draw_circuits_test",
        "peekOfCode": "def strL(val):\n    print(val)\n    return f'{float(val)/n:.2f}nH'\ni = 1\nfor name, circuit,values in filters:\n    print(values)\n    components = [int(float(x)) for x in circuit.replace('[','').replace(']','').split(' ') if x]\n    cvs = []\n    for ic in components:\n        if ic==1:",
        "detail": "_old_python_files.draw_circuits_test",
        "documentation": {}
    },
    {
        "label": "filters",
        "kind": 5,
        "importPath": "_old_python_files.draw_circuits_test",
        "description": "_old_python_files.draw_circuits_test",
        "peekOfCode": "filters = []\nwith open(\"filter_results_steep_ig.txt\",'r') as f:\n    lines = f.read().split('\\n')\n    for line in lines:\n        if not line:\n            continue\n        name, circuit, *vals = line.split(',')\n        filters.append((name, circuit,vals))\np = 1e-12\nn = 1e-9",
        "detail": "_old_python_files.draw_circuits_test",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "_old_python_files.draw_circuits_test",
        "description": "_old_python_files.draw_circuits_test",
        "peekOfCode": "p = 1e-12\nn = 1e-9\ndef strC(val):\n    print(val)\n    return f'{float(val)/p:.2f}pF'\ndef strL(val):\n    print(val)\n    return f'{float(val)/n:.2f}nH'\ni = 1\nfor name, circuit,values in filters:",
        "detail": "_old_python_files.draw_circuits_test",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "_old_python_files.draw_circuits_test",
        "description": "_old_python_files.draw_circuits_test",
        "peekOfCode": "n = 1e-9\ndef strC(val):\n    print(val)\n    return f'{float(val)/p:.2f}pF'\ndef strL(val):\n    print(val)\n    return f'{float(val)/n:.2f}nH'\ni = 1\nfor name, circuit,values in filters:\n    print(values)",
        "detail": "_old_python_files.draw_circuits_test",
        "documentation": {}
    },
    {
        "label": "i",
        "kind": 5,
        "importPath": "_old_python_files.draw_circuits_test",
        "description": "_old_python_files.draw_circuits_test",
        "peekOfCode": "i = 1\nfor name, circuit,values in filters:\n    print(values)\n    components = [int(float(x)) for x in circuit.replace('[','').replace(']','').split(' ') if x]\n    cvs = []\n    for ic in components:\n        if ic==1:\n            cvs.append(values.pop(0))\n        else:\n            cvs.append('')",
        "detail": "_old_python_files.draw_circuits_test",
        "documentation": {}
    },
    {
        "label": "pF",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "pF = 1e-12\nnH = 1e-9\nM = hv.Model()\np1 = M.new_port(50)\np2 = M.new_port(50)\nn1 = M.node()\nM.capacitor(M.gnd, p1, 0.774*pF)\nM.capacitor(p1, n1, 5.96*pF)\nM.inductor(p1, n1, 0.30*nH)\nM.inductor(M.gnd, n1, 0.29*nH)",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "nH",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "nH = 1e-9\nM = hv.Model()\np1 = M.new_port(50)\np2 = M.new_port(50)\nn1 = M.node()\nM.capacitor(M.gnd, p1, 0.774*pF)\nM.capacitor(p1, n1, 5.96*pF)\nM.inductor(p1, n1, 0.30*nH)\nM.inductor(M.gnd, n1, 0.29*nH)\nM.capacitor(M.gnd, n1, 9.72*pF)",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "M = hv.Model()\np1 = M.new_port(50)\np2 = M.new_port(50)\nn1 = M.node()\nM.capacitor(M.gnd, p1, 0.774*pF)\nM.capacitor(p1, n1, 5.96*pF)\nM.inductor(p1, n1, 0.30*nH)\nM.inductor(M.gnd, n1, 0.29*nH)\nM.capacitor(M.gnd, n1, 9.72*pF)\nM.inductor(n1,p2, 1.86*nH)",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "p1 = M.new_port(50)\np2 = M.new_port(50)\nn1 = M.node()\nM.capacitor(M.gnd, p1, 0.774*pF)\nM.capacitor(p1, n1, 5.96*pF)\nM.inductor(p1, n1, 0.30*nH)\nM.inductor(M.gnd, n1, 0.29*nH)\nM.capacitor(M.gnd, n1, 9.72*pF)\nM.inductor(n1,p2, 1.86*nH)\nM.inductor(p2,M.gnd, 0.75*nH)",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "p2 = M.new_port(50)\nn1 = M.node()\nM.capacitor(M.gnd, p1, 0.774*pF)\nM.capacitor(p1, n1, 5.96*pF)\nM.inductor(p1, n1, 0.30*nH)\nM.inductor(M.gnd, n1, 0.29*nH)\nM.capacitor(M.gnd, n1, 9.72*pF)\nM.inductor(n1,p2, 1.86*nH)\nM.inductor(p2,M.gnd, 0.75*nH)\nM.capacitor(p2, M.gnd, 4.52*pF)",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "n1 = M.node()\nM.capacitor(M.gnd, p1, 0.774*pF)\nM.capacitor(p1, n1, 5.96*pF)\nM.inductor(p1, n1, 0.30*nH)\nM.inductor(M.gnd, n1, 0.29*nH)\nM.capacitor(M.gnd, n1, 9.72*pF)\nM.inductor(n1,p2, 1.86*nH)\nM.inductor(p2,M.gnd, 0.75*nH)\nM.capacitor(p2, M.gnd, 4.52*pF)\nfs = hv.frange(2e9, 6e9, 1001)",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "fs",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "fs = hv.frange(2e9, 6e9, 1001)\nS = M.run(fs)\n## Comparable filter\nM2 = hv.Model()\np12 = M2.new_port(50)\np22 = M2.new_port(50)\nf1 = 3e9\nf2 = 3.5e9\nM2.filters.cauer_filter(M2.gnd, p12, p22, 0.5*(f1+f2), f2-f1, 4, 0.01, hv.FilterType.CHEBYCHEV, hv.BandType.BANDPASS)\nM2.print_components()",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "S = M.run(fs)\n## Comparable filter\nM2 = hv.Model()\np12 = M2.new_port(50)\np22 = M2.new_port(50)\nf1 = 3e9\nf2 = 3.5e9\nM2.filters.cauer_filter(M2.gnd, p12, p22, 0.5*(f1+f2), f2-f1, 4, 0.01, hv.FilterType.CHEBYCHEV, hv.BandType.BANDPASS)\nM2.print_components()\nS2 = M2.run(fs)",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "M2",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "M2 = hv.Model()\np12 = M2.new_port(50)\np22 = M2.new_port(50)\nf1 = 3e9\nf2 = 3.5e9\nM2.filters.cauer_filter(M2.gnd, p12, p22, 0.5*(f1+f2), f2-f1, 4, 0.01, hv.FilterType.CHEBYCHEV, hv.BandType.BANDPASS)\nM2.print_components()\nS2 = M2.run(fs)\nhv.plot_s_parameters(fs,[S.S11, S.S21, S2.S11, S2.S21], labels=['S11','S21','S11 Chebychev','S21 Chebychev'], colorcycle=[0,1,0,1], linestyles=['-','-','--','--'])",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "p12",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "p12 = M2.new_port(50)\np22 = M2.new_port(50)\nf1 = 3e9\nf2 = 3.5e9\nM2.filters.cauer_filter(M2.gnd, p12, p22, 0.5*(f1+f2), f2-f1, 4, 0.01, hv.FilterType.CHEBYCHEV, hv.BandType.BANDPASS)\nM2.print_components()\nS2 = M2.run(fs)\nhv.plot_s_parameters(fs,[S.S11, S.S21, S2.S11, S2.S21], labels=['S11','S21','S11 Chebychev','S21 Chebychev'], colorcycle=[0,1,0,1], linestyles=['-','-','--','--'])",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "p22",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "p22 = M2.new_port(50)\nf1 = 3e9\nf2 = 3.5e9\nM2.filters.cauer_filter(M2.gnd, p12, p22, 0.5*(f1+f2), f2-f1, 4, 0.01, hv.FilterType.CHEBYCHEV, hv.BandType.BANDPASS)\nM2.print_components()\nS2 = M2.run(fs)\nhv.plot_s_parameters(fs,[S.S11, S.S21, S2.S11, S2.S21], labels=['S11','S21','S11 Chebychev','S21 Chebychev'], colorcycle=[0,1,0,1], linestyles=['-','-','--','--'])",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "f1",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "f1 = 3e9\nf2 = 3.5e9\nM2.filters.cauer_filter(M2.gnd, p12, p22, 0.5*(f1+f2), f2-f1, 4, 0.01, hv.FilterType.CHEBYCHEV, hv.BandType.BANDPASS)\nM2.print_components()\nS2 = M2.run(fs)\nhv.plot_s_parameters(fs,[S.S11, S.S21, S2.S11, S2.S21], labels=['S11','S21','S11 Chebychev','S21 Chebychev'], colorcycle=[0,1,0,1], linestyles=['-','-','--','--'])",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "f2",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "f2 = 3.5e9\nM2.filters.cauer_filter(M2.gnd, p12, p22, 0.5*(f1+f2), f2-f1, 4, 0.01, hv.FilterType.CHEBYCHEV, hv.BandType.BANDPASS)\nM2.print_components()\nS2 = M2.run(fs)\nhv.plot_s_parameters(fs,[S.S11, S.S21, S2.S11, S2.S21], labels=['S11','S21','S11 Chebychev','S21 Chebychev'], colorcycle=[0,1,0,1], linestyles=['-','-','--','--'])",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "S2",
        "kind": 5,
        "importPath": "_old_python_files.filter_post_test",
        "description": "_old_python_files.filter_post_test",
        "peekOfCode": "S2 = M2.run(fs)\nhv.plot_s_parameters(fs,[S.S11, S.S21, S2.S11, S2.S21], labels=['S11','S21','S11 Chebychev','S21 Chebychev'], colorcycle=[0,1,0,1], linestyles=['-','-','--','--'])",
        "detail": "_old_python_files.filter_post_test",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "_old_python_files.heavi_test",
        "description": "_old_python_files.heavi_test",
        "peekOfCode": "model = hf.Model(suppress_loadbar=True)\nmc = hf.MonteCarlo()\nn1 = model.node()\np1 = model.terminal(n1, 50)\nn2 = model.node()\n#n3 = model.node()\nZ0s = mc.gaussian(50,5)\np2 = model.terminal(n2, Z0s)\n#resistor = smd.SMDResistor(5, smd.SMDResistorSize.R0402).connect(n2,n3)\nmodel.filters.cauer_filter(model.gnd, n1, n2, 2e9, 70e6, 5, 0.03, hf.FilterType.CHEBYCHEV, type=hf.BandType.BANDPASS)",
        "detail": "_old_python_files.heavi_test",
        "documentation": {}
    },
    {
        "label": "mc",
        "kind": 5,
        "importPath": "_old_python_files.heavi_test",
        "description": "_old_python_files.heavi_test",
        "peekOfCode": "mc = hf.MonteCarlo()\nn1 = model.node()\np1 = model.terminal(n1, 50)\nn2 = model.node()\n#n3 = model.node()\nZ0s = mc.gaussian(50,5)\np2 = model.terminal(n2, Z0s)\n#resistor = smd.SMDResistor(5, smd.SMDResistorSize.R0402).connect(n2,n3)\nmodel.filters.cauer_filter(model.gnd, n1, n2, 2e9, 70e6, 5, 0.03, hf.FilterType.CHEBYCHEV, type=hf.BandType.BANDPASS)\nf = hf.frange(1.8e9, 2.2e9, 2001)",
        "detail": "_old_python_files.heavi_test",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "_old_python_files.heavi_test",
        "description": "_old_python_files.heavi_test",
        "peekOfCode": "n1 = model.node()\np1 = model.terminal(n1, 50)\nn2 = model.node()\n#n3 = model.node()\nZ0s = mc.gaussian(50,5)\np2 = model.terminal(n2, Z0s)\n#resistor = smd.SMDResistor(5, smd.SMDResistorSize.R0402).connect(n2,n3)\nmodel.filters.cauer_filter(model.gnd, n1, n2, 2e9, 70e6, 5, 0.03, hf.FilterType.CHEBYCHEV, type=hf.BandType.BANDPASS)\nf = hf.frange(1.8e9, 2.2e9, 2001)\nsweep = hf.ParameterSweep()",
        "detail": "_old_python_files.heavi_test",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "_old_python_files.heavi_test",
        "description": "_old_python_files.heavi_test",
        "peekOfCode": "p1 = model.terminal(n1, 50)\nn2 = model.node()\n#n3 = model.node()\nZ0s = mc.gaussian(50,5)\np2 = model.terminal(n2, Z0s)\n#resistor = smd.SMDResistor(5, smd.SMDResistorSize.R0402).connect(n2,n3)\nmodel.filters.cauer_filter(model.gnd, n1, n2, 2e9, 70e6, 5, 0.03, hf.FilterType.CHEBYCHEV, type=hf.BandType.BANDPASS)\nf = hf.frange(1.8e9, 2.2e9, 2001)\nsweep = hf.ParameterSweep()\nsweep.add_dimension(Z0s)",
        "detail": "_old_python_files.heavi_test",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "_old_python_files.heavi_test",
        "description": "_old_python_files.heavi_test",
        "peekOfCode": "n2 = model.node()\n#n3 = model.node()\nZ0s = mc.gaussian(50,5)\np2 = model.terminal(n2, Z0s)\n#resistor = smd.SMDResistor(5, smd.SMDResistorSize.R0402).connect(n2,n3)\nmodel.filters.cauer_filter(model.gnd, n1, n2, 2e9, 70e6, 5, 0.03, hf.FilterType.CHEBYCHEV, type=hf.BandType.BANDPASS)\nf = hf.frange(1.8e9, 2.2e9, 2001)\nsweep = hf.ParameterSweep()\nsweep.add_dimension(Z0s)\nfor indices in mc.iterate(10):",
        "detail": "_old_python_files.heavi_test",
        "documentation": {}
    },
    {
        "label": "#n3",
        "kind": 5,
        "importPath": "_old_python_files.heavi_test",
        "description": "_old_python_files.heavi_test",
        "peekOfCode": "#n3 = model.node()\nZ0s = mc.gaussian(50,5)\np2 = model.terminal(n2, Z0s)\n#resistor = smd.SMDResistor(5, smd.SMDResistorSize.R0402).connect(n2,n3)\nmodel.filters.cauer_filter(model.gnd, n1, n2, 2e9, 70e6, 5, 0.03, hf.FilterType.CHEBYCHEV, type=hf.BandType.BANDPASS)\nf = hf.frange(1.8e9, 2.2e9, 2001)\nsweep = hf.ParameterSweep()\nsweep.add_dimension(Z0s)\nfor indices in mc.iterate(10):\n    S = model.run_sparameter_analysis(f)",
        "detail": "_old_python_files.heavi_test",
        "documentation": {}
    },
    {
        "label": "Z0s",
        "kind": 5,
        "importPath": "_old_python_files.heavi_test",
        "description": "_old_python_files.heavi_test",
        "peekOfCode": "Z0s = mc.gaussian(50,5)\np2 = model.terminal(n2, Z0s)\n#resistor = smd.SMDResistor(5, smd.SMDResistorSize.R0402).connect(n2,n3)\nmodel.filters.cauer_filter(model.gnd, n1, n2, 2e9, 70e6, 5, 0.03, hf.FilterType.CHEBYCHEV, type=hf.BandType.BANDPASS)\nf = hf.frange(1.8e9, 2.2e9, 2001)\nsweep = hf.ParameterSweep()\nsweep.add_dimension(Z0s)\nfor indices in mc.iterate(10):\n    S = model.run_sparameter_analysis(f)\n    hf.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])",
        "detail": "_old_python_files.heavi_test",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "_old_python_files.heavi_test",
        "description": "_old_python_files.heavi_test",
        "peekOfCode": "p2 = model.terminal(n2, Z0s)\n#resistor = smd.SMDResistor(5, smd.SMDResistorSize.R0402).connect(n2,n3)\nmodel.filters.cauer_filter(model.gnd, n1, n2, 2e9, 70e6, 5, 0.03, hf.FilterType.CHEBYCHEV, type=hf.BandType.BANDPASS)\nf = hf.frange(1.8e9, 2.2e9, 2001)\nsweep = hf.ParameterSweep()\nsweep.add_dimension(Z0s)\nfor indices in mc.iterate(10):\n    S = model.run_sparameter_analysis(f)\n    hf.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])\nmodel.print_components()",
        "detail": "_old_python_files.heavi_test",
        "documentation": {}
    },
    {
        "label": "#resistor",
        "kind": 5,
        "importPath": "_old_python_files.heavi_test",
        "description": "_old_python_files.heavi_test",
        "peekOfCode": "#resistor = smd.SMDResistor(5, smd.SMDResistorSize.R0402).connect(n2,n3)\nmodel.filters.cauer_filter(model.gnd, n1, n2, 2e9, 70e6, 5, 0.03, hf.FilterType.CHEBYCHEV, type=hf.BandType.BANDPASS)\nf = hf.frange(1.8e9, 2.2e9, 2001)\nsweep = hf.ParameterSweep()\nsweep.add_dimension(Z0s)\nfor indices in mc.iterate(10):\n    S = model.run_sparameter_analysis(f)\n    hf.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])\nmodel.print_components()\n# for component in model.components:",
        "detail": "_old_python_files.heavi_test",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "_old_python_files.heavi_test",
        "description": "_old_python_files.heavi_test",
        "peekOfCode": "f = hf.frange(1.8e9, 2.2e9, 2001)\nsweep = hf.ParameterSweep()\nsweep.add_dimension(Z0s)\nfor indices in mc.iterate(10):\n    S = model.run_sparameter_analysis(f)\n    hf.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])\nmodel.print_components()\n# for component in model.components:\n#     print(component)\n#     for func in component.functionlist:",
        "detail": "_old_python_files.heavi_test",
        "documentation": {}
    },
    {
        "label": "sweep",
        "kind": 5,
        "importPath": "_old_python_files.heavi_test",
        "description": "_old_python_files.heavi_test",
        "peekOfCode": "sweep = hf.ParameterSweep()\nsweep.add_dimension(Z0s)\nfor indices in mc.iterate(10):\n    S = model.run_sparameter_analysis(f)\n    hf.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])\nmodel.print_components()\n# for component in model.components:\n#     print(component)\n#     for func in component.functionlist:\n#         print(f'Value at 1GHz: {func.simval(1e9)}')",
        "detail": "_old_python_files.heavi_test",
        "documentation": {}
    },
    {
        "label": "run_matrix",
        "kind": 2,
        "importPath": "_old_python_files.kaband_filter_test",
        "description": "_old_python_files.kaband_filter_test",
        "peekOfCode": "def run_matrix(name: str, LC: np.ndarray, vallimit: float):\n    tot_nodes = LC.shape[0]\n    n_extra = tot_nodes-3\n    if n_extra < 1:\n        raise ValueError('Only works for 1 extra node')\n    M = hv.Model(suppress_loadbar=True)\n    O = opt.Optimiser(M)\n    p1 = M.new_port(50)\n    p2 = M.new_port(50)\n    nodes = [M.gnd, p1] + [M.node() for _ in range(n_extra)] + [p2,]",
        "detail": "_old_python_files.kaband_filter_test",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "_old_python_files.kaband_filter_test",
        "description": "_old_python_files.kaband_filter_test",
        "peekOfCode": "N = 1 + 3\nids = [(i,j) for i in range(N) for j in range(N) if i!=j]\nfrom itertools import permutations\ncompleted = set()\nctr = 0\ninitial = 2\nfor options in permutations(ids, 6):\n    ctr+=1\n    if ctr < 0:\n        continue",
        "detail": "_old_python_files.kaband_filter_test",
        "documentation": {}
    },
    {
        "label": "ids",
        "kind": 5,
        "importPath": "_old_python_files.kaband_filter_test",
        "description": "_old_python_files.kaband_filter_test",
        "peekOfCode": "ids = [(i,j) for i in range(N) for j in range(N) if i!=j]\nfrom itertools import permutations\ncompleted = set()\nctr = 0\ninitial = 2\nfor options in permutations(ids, 6):\n    ctr+=1\n    if ctr < 0:\n        continue\n    net = np.zeros((N,N))",
        "detail": "_old_python_files.kaband_filter_test",
        "documentation": {}
    },
    {
        "label": "completed",
        "kind": 5,
        "importPath": "_old_python_files.kaband_filter_test",
        "description": "_old_python_files.kaband_filter_test",
        "peekOfCode": "completed = set()\nctr = 0\ninitial = 2\nfor options in permutations(ids, 6):\n    ctr+=1\n    if ctr < 0:\n        continue\n    net = np.zeros((N,N))\n    tupnet = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]\n    for (i,j) in options:",
        "detail": "_old_python_files.kaband_filter_test",
        "documentation": {}
    },
    {
        "label": "ctr",
        "kind": 5,
        "importPath": "_old_python_files.kaband_filter_test",
        "description": "_old_python_files.kaband_filter_test",
        "peekOfCode": "ctr = 0\ninitial = 2\nfor options in permutations(ids, 6):\n    ctr+=1\n    if ctr < 0:\n        continue\n    net = np.zeros((N,N))\n    tupnet = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]\n    for (i,j) in options:\n        net[i,j] = 1",
        "detail": "_old_python_files.kaband_filter_test",
        "documentation": {}
    },
    {
        "label": "initial",
        "kind": 5,
        "importPath": "_old_python_files.kaband_filter_test",
        "description": "_old_python_files.kaband_filter_test",
        "peekOfCode": "initial = 2\nfor options in permutations(ids, 6):\n    ctr+=1\n    if ctr < 0:\n        continue\n    net = np.zeros((N,N))\n    tupnet = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]\n    for (i,j) in options:\n        net[i,j] = 1\n        tupnet[i][j] = 1",
        "detail": "_old_python_files.kaband_filter_test",
        "documentation": {}
    },
    {
        "label": "callback",
        "kind": 2,
        "importPath": "_old_python_files.optimize_test",
        "description": "_old_python_files.optimize_test",
        "peekOfCode": "def callback(*args, **kwargs):\n    print(args, kwargs)\ndifferential_evolution(O.generate_objective(2, differential_weighting=0), \n                       bounds=O.bounds, \n                       popsize=10, \n                       callback=callback \n                       )#x0=np.array([-12.20445962, -11.85881477,  -8.84360019, -11.85278029,-12.27916784,  -8.61153167, -12.07183129]))\n#dual_annealing(O.generate_objective(2, differential_weighting=True, differential_weighting_exponent=5), bounds=O.bounds)\n#minimize(O.generate_objective(2, differential_weighting=True), O.x0, bounds=O.bounds, method='Nelder-Mead')\nf = hv.frange(0.1e9, 10e9,1001)",
        "detail": "_old_python_files.optimize_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "_old_python_files.optimize_test",
        "description": "_old_python_files.optimize_test",
        "peekOfCode": "M = hv.Model(suppress_loadbar=True)\nO = opt.Optimiser(M)\np1 = M.new_port(50)\np2 = M.new_port(50)\nn1 = M.node()\nM.capacitor(M.gnd, p1, O.cap())\nM.capacitor(p1, n1, O.cap())\nM.inductor(p1, n1, O.ind())\nM.capacitor(M.gnd, n1, O.cap())\nM.capacitor(n1,p2,O.cap())",
        "detail": "_old_python_files.optimize_test",
        "documentation": {}
    },
    {
        "label": "O",
        "kind": 5,
        "importPath": "_old_python_files.optimize_test",
        "description": "_old_python_files.optimize_test",
        "peekOfCode": "O = opt.Optimiser(M)\np1 = M.new_port(50)\np2 = M.new_port(50)\nn1 = M.node()\nM.capacitor(M.gnd, p1, O.cap())\nM.capacitor(p1, n1, O.cap())\nM.inductor(p1, n1, O.ind())\nM.capacitor(M.gnd, n1, O.cap())\nM.capacitor(n1,p2,O.cap())\nM.inductor(n1,p2,O.ind())",
        "detail": "_old_python_files.optimize_test",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "_old_python_files.optimize_test",
        "description": "_old_python_files.optimize_test",
        "peekOfCode": "p1 = M.new_port(50)\np2 = M.new_port(50)\nn1 = M.node()\nM.capacitor(M.gnd, p1, O.cap())\nM.capacitor(p1, n1, O.cap())\nM.inductor(p1, n1, O.ind())\nM.capacitor(M.gnd, n1, O.cap())\nM.capacitor(n1,p2,O.cap())\nM.inductor(n1,p2,O.ind())\nM.capacitor(M.gnd,p2, O.cap())",
        "detail": "_old_python_files.optimize_test",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "_old_python_files.optimize_test",
        "description": "_old_python_files.optimize_test",
        "peekOfCode": "p2 = M.new_port(50)\nn1 = M.node()\nM.capacitor(M.gnd, p1, O.cap())\nM.capacitor(p1, n1, O.cap())\nM.inductor(p1, n1, O.ind())\nM.capacitor(M.gnd, n1, O.cap())\nM.capacitor(n1,p2,O.cap())\nM.inductor(n1,p2,O.ind())\nM.capacitor(M.gnd,p2, O.cap())\nL1 = -15",
        "detail": "_old_python_files.optimize_test",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "_old_python_files.optimize_test",
        "description": "_old_python_files.optimize_test",
        "peekOfCode": "n1 = M.node()\nM.capacitor(M.gnd, p1, O.cap())\nM.capacitor(p1, n1, O.cap())\nM.inductor(p1, n1, O.ind())\nM.capacitor(M.gnd, n1, O.cap())\nM.capacitor(n1,p2,O.cap())\nM.inductor(n1,p2,O.ind())\nM.capacitor(M.gnd,p2, O.cap())\nL1 = -15\nL2 = -30",
        "detail": "_old_python_files.optimize_test",
        "documentation": {}
    },
    {
        "label": "L1",
        "kind": 5,
        "importPath": "_old_python_files.optimize_test",
        "description": "_old_python_files.optimize_test",
        "peekOfCode": "L1 = -15\nL2 = -30\nL3 = -20\nO.add_goal(0.1e9, 3e9, 11, (1,1), opt.dBbelow(L1, norm=4), weight=1)\nO.add_goal(3.5e9, 5e9, 21, (2,1), opt.dBbelow(L2, norm=4), weight=1)\nO.add_goal(5e9, 10e9, 21, (2,1), opt.dBbelow(L3, norm=4), weight=1)\n#O.add_goal(0.1e9, 1.5e9, 21, (2,1), opt.dBbelow(-5), weight=1)\n#O.add_goal(3.5e9, 5e9, 21, (2,1), opt.dBbelow(-5), weight=1)\ndef callback(*args, **kwargs):\n    print(args, kwargs)",
        "detail": "_old_python_files.optimize_test",
        "documentation": {}
    },
    {
        "label": "L2",
        "kind": 5,
        "importPath": "_old_python_files.optimize_test",
        "description": "_old_python_files.optimize_test",
        "peekOfCode": "L2 = -30\nL3 = -20\nO.add_goal(0.1e9, 3e9, 11, (1,1), opt.dBbelow(L1, norm=4), weight=1)\nO.add_goal(3.5e9, 5e9, 21, (2,1), opt.dBbelow(L2, norm=4), weight=1)\nO.add_goal(5e9, 10e9, 21, (2,1), opt.dBbelow(L3, norm=4), weight=1)\n#O.add_goal(0.1e9, 1.5e9, 21, (2,1), opt.dBbelow(-5), weight=1)\n#O.add_goal(3.5e9, 5e9, 21, (2,1), opt.dBbelow(-5), weight=1)\ndef callback(*args, **kwargs):\n    print(args, kwargs)\ndifferential_evolution(O.generate_objective(2, differential_weighting=0), ",
        "detail": "_old_python_files.optimize_test",
        "documentation": {}
    },
    {
        "label": "L3",
        "kind": 5,
        "importPath": "_old_python_files.optimize_test",
        "description": "_old_python_files.optimize_test",
        "peekOfCode": "L3 = -20\nO.add_goal(0.1e9, 3e9, 11, (1,1), opt.dBbelow(L1, norm=4), weight=1)\nO.add_goal(3.5e9, 5e9, 21, (2,1), opt.dBbelow(L2, norm=4), weight=1)\nO.add_goal(5e9, 10e9, 21, (2,1), opt.dBbelow(L3, norm=4), weight=1)\n#O.add_goal(0.1e9, 1.5e9, 21, (2,1), opt.dBbelow(-5), weight=1)\n#O.add_goal(3.5e9, 5e9, 21, (2,1), opt.dBbelow(-5), weight=1)\ndef callback(*args, **kwargs):\n    print(args, kwargs)\ndifferential_evolution(O.generate_objective(2, differential_weighting=0), \n                       bounds=O.bounds, ",
        "detail": "_old_python_files.optimize_test",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "_old_python_files.optimize_test",
        "description": "_old_python_files.optimize_test",
        "peekOfCode": "f = hv.frange(0.1e9, 10e9,1001)\nM.print_components()\nS = M.run(f)\nhv.plot_s_parameters(f,[S.S11, S.S21], labels=['S11','S21'], spec_area=[opt.gen_fill_area(0e9,3e9,below=L1),opt.gen_fill_area(3.5e9,5e9,below=L2),opt.gen_fill_area(5e9,10e9,below=L3)])",
        "detail": "_old_python_files.optimize_test",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "_old_python_files.optimize_test",
        "description": "_old_python_files.optimize_test",
        "peekOfCode": "S = M.run(f)\nhv.plot_s_parameters(f,[S.S11, S.S21], labels=['S11','S21'], spec_area=[opt.gen_fill_area(0e9,3e9,below=L1),opt.gen_fill_area(3.5e9,5e9,below=L2),opt.gen_fill_area(5e9,10e9,below=L3)])",
        "detail": "_old_python_files.optimize_test",
        "documentation": {}
    },
    {
        "label": "mm",
        "kind": 5,
        "importPath": "_old_python_files.pcb_route_test",
        "description": "_old_python_files.pcb_route_test",
        "peekOfCode": "mm = 0.001\nM = hv.Model()\npcb = pcb.PCBStack(M, 3.4, 0.02, 0.002, 4)\noutput = pcb.port(50, layer=0).chebychev_transformer(100,3e9, 1, 0.04).terminate(100)\nf = hv.frange(1e9, 10e9, 1001)\nS = M.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])\nM.print_components()",
        "detail": "_old_python_files.pcb_route_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "_old_python_files.pcb_route_test",
        "description": "_old_python_files.pcb_route_test",
        "peekOfCode": "M = hv.Model()\npcb = pcb.PCBStack(M, 3.4, 0.02, 0.002, 4)\noutput = pcb.port(50, layer=0).chebychev_transformer(100,3e9, 1, 0.04).terminate(100)\nf = hv.frange(1e9, 10e9, 1001)\nS = M.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])\nM.print_components()",
        "detail": "_old_python_files.pcb_route_test",
        "documentation": {}
    },
    {
        "label": "pcb",
        "kind": 5,
        "importPath": "_old_python_files.pcb_route_test",
        "description": "_old_python_files.pcb_route_test",
        "peekOfCode": "pcb = pcb.PCBStack(M, 3.4, 0.02, 0.002, 4)\noutput = pcb.port(50, layer=0).chebychev_transformer(100,3e9, 1, 0.04).terminate(100)\nf = hv.frange(1e9, 10e9, 1001)\nS = M.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])\nM.print_components()",
        "detail": "_old_python_files.pcb_route_test",
        "documentation": {}
    },
    {
        "label": "output",
        "kind": 5,
        "importPath": "_old_python_files.pcb_route_test",
        "description": "_old_python_files.pcb_route_test",
        "peekOfCode": "output = pcb.port(50, layer=0).chebychev_transformer(100,3e9, 1, 0.04).terminate(100)\nf = hv.frange(1e9, 10e9, 1001)\nS = M.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])\nM.print_components()",
        "detail": "_old_python_files.pcb_route_test",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "_old_python_files.pcb_route_test",
        "description": "_old_python_files.pcb_route_test",
        "peekOfCode": "f = hv.frange(1e9, 10e9, 1001)\nS = M.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])\nM.print_components()",
        "detail": "_old_python_files.pcb_route_test",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "_old_python_files.pcb_route_test",
        "description": "_old_python_files.pcb_route_test",
        "peekOfCode": "S = M.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])\nM.print_components()",
        "detail": "_old_python_files.pcb_route_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "_old_python_files.stochastic_test",
        "description": "_old_python_files.stochastic_test",
        "peekOfCode": "M = hv.Model(suppress_loadbar=False)\nmcsim = mc.MonteCarlo()\nn1 = M.new_port(50)\nn2 = M.new_port(50)\nTL = mc.TransmissionLine(mcsim, 1, 50, VSWR=1.05, phase_stability=5, Z0_error=1).connect(n1, n2)\nS11s = []\nS21s = []\nfs = np.linspace(1e9, 2e9, 21)\nM.print_components()\nprint(mcsim._random_numbers)",
        "detail": "_old_python_files.stochastic_test",
        "documentation": {}
    },
    {
        "label": "mcsim",
        "kind": 5,
        "importPath": "_old_python_files.stochastic_test",
        "description": "_old_python_files.stochastic_test",
        "peekOfCode": "mcsim = mc.MonteCarlo()\nn1 = M.new_port(50)\nn2 = M.new_port(50)\nTL = mc.TransmissionLine(mcsim, 1, 50, VSWR=1.05, phase_stability=5, Z0_error=1).connect(n1, n2)\nS11s = []\nS21s = []\nfs = np.linspace(1e9, 2e9, 21)\nM.print_components()\nprint(mcsim._random_numbers)\nfor i in mcsim.iterate(500):",
        "detail": "_old_python_files.stochastic_test",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "_old_python_files.stochastic_test",
        "description": "_old_python_files.stochastic_test",
        "peekOfCode": "n1 = M.new_port(50)\nn2 = M.new_port(50)\nTL = mc.TransmissionLine(mcsim, 1, 50, VSWR=1.05, phase_stability=5, Z0_error=1).connect(n1, n2)\nS11s = []\nS21s = []\nfs = np.linspace(1e9, 2e9, 21)\nM.print_components()\nprint(mcsim._random_numbers)\nfor i in mcsim.iterate(500):\n    S = M.run(fs)",
        "detail": "_old_python_files.stochastic_test",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "_old_python_files.stochastic_test",
        "description": "_old_python_files.stochastic_test",
        "peekOfCode": "n2 = M.new_port(50)\nTL = mc.TransmissionLine(mcsim, 1, 50, VSWR=1.05, phase_stability=5, Z0_error=1).connect(n1, n2)\nS11s = []\nS21s = []\nfs = np.linspace(1e9, 2e9, 21)\nM.print_components()\nprint(mcsim._random_numbers)\nfor i in mcsim.iterate(500):\n    S = M.run(fs)\n    S11s.append(S.S11)",
        "detail": "_old_python_files.stochastic_test",
        "documentation": {}
    },
    {
        "label": "TL",
        "kind": 5,
        "importPath": "_old_python_files.stochastic_test",
        "description": "_old_python_files.stochastic_test",
        "peekOfCode": "TL = mc.TransmissionLine(mcsim, 1, 50, VSWR=1.05, phase_stability=5, Z0_error=1).connect(n1, n2)\nS11s = []\nS21s = []\nfs = np.linspace(1e9, 2e9, 21)\nM.print_components()\nprint(mcsim._random_numbers)\nfor i in mcsim.iterate(500):\n    S = M.run(fs)\n    S11s.append(S.S11)\n    S21s.append(S.S21)",
        "detail": "_old_python_files.stochastic_test",
        "documentation": {}
    },
    {
        "label": "S11s",
        "kind": 5,
        "importPath": "_old_python_files.stochastic_test",
        "description": "_old_python_files.stochastic_test",
        "peekOfCode": "S11s = []\nS21s = []\nfs = np.linspace(1e9, 2e9, 21)\nM.print_components()\nprint(mcsim._random_numbers)\nfor i in mcsim.iterate(500):\n    S = M.run(fs)\n    S11s.append(S.S11)\n    S21s.append(S.S21)\n(Amu, Asig), (Pmu, Psig) = analyse_sparameter(S21s, S21s, phase_reference=np.exp(1j*2*np.pi*fs/299792458))",
        "detail": "_old_python_files.stochastic_test",
        "documentation": {}
    },
    {
        "label": "S21s",
        "kind": 5,
        "importPath": "_old_python_files.stochastic_test",
        "description": "_old_python_files.stochastic_test",
        "peekOfCode": "S21s = []\nfs = np.linspace(1e9, 2e9, 21)\nM.print_components()\nprint(mcsim._random_numbers)\nfor i in mcsim.iterate(500):\n    S = M.run(fs)\n    S11s.append(S.S11)\n    S21s.append(S.S21)\n(Amu, Asig), (Pmu, Psig) = analyse_sparameter(S21s, S21s, phase_reference=np.exp(1j*2*np.pi*fs/299792458))",
        "detail": "_old_python_files.stochastic_test",
        "documentation": {}
    },
    {
        "label": "fs",
        "kind": 5,
        "importPath": "_old_python_files.stochastic_test",
        "description": "_old_python_files.stochastic_test",
        "peekOfCode": "fs = np.linspace(1e9, 2e9, 21)\nM.print_components()\nprint(mcsim._random_numbers)\nfor i in mcsim.iterate(500):\n    S = M.run(fs)\n    S11s.append(S.S11)\n    S21s.append(S.S21)\n(Amu, Asig), (Pmu, Psig) = analyse_sparameter(S21s, S21s, phase_reference=np.exp(1j*2*np.pi*fs/299792458))",
        "detail": "_old_python_files.stochastic_test",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "_old_python_files.sweep_test",
        "description": "_old_python_files.sweep_test",
        "peekOfCode": "model = hv.Model(suppress_loadbar=True)\np1 = model.new_port(50)\np2 = model.new_port(50)\nn1 = model.node()\nsweep = hv.ParameterSweep()\nR1, R2 = sweep.lin(50,100).lin(20,200).add(5)\nC3 = hv.Param.lin(1e-12, 10e-12, 10)\nsweep.add_dimension(C3)\nR1 = model.resistor(p1, n1, R1)\nR2 = model.resistor(n1, p2, R2)",
        "detail": "_old_python_files.sweep_test",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "_old_python_files.sweep_test",
        "description": "_old_python_files.sweep_test",
        "peekOfCode": "p1 = model.new_port(50)\np2 = model.new_port(50)\nn1 = model.node()\nsweep = hv.ParameterSweep()\nR1, R2 = sweep.lin(50,100).lin(20,200).add(5)\nC3 = hv.Param.lin(1e-12, 10e-12, 10)\nsweep.add_dimension(C3)\nR1 = model.resistor(p1, n1, R1)\nR2 = model.resistor(n1, p2, R2)\nC = model.capacitor(n1, model.gnd, C3)",
        "detail": "_old_python_files.sweep_test",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "_old_python_files.sweep_test",
        "description": "_old_python_files.sweep_test",
        "peekOfCode": "p2 = model.new_port(50)\nn1 = model.node()\nsweep = hv.ParameterSweep()\nR1, R2 = sweep.lin(50,100).lin(20,200).add(5)\nC3 = hv.Param.lin(1e-12, 10e-12, 10)\nsweep.add_dimension(C3)\nR1 = model.resistor(p1, n1, R1)\nR2 = model.resistor(n1, p2, R2)\nC = model.capacitor(n1, model.gnd, C3)\nf = hv.frange(1e6, 10e9,10_001)",
        "detail": "_old_python_files.sweep_test",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "_old_python_files.sweep_test",
        "description": "_old_python_files.sweep_test",
        "peekOfCode": "n1 = model.node()\nsweep = hv.ParameterSweep()\nR1, R2 = sweep.lin(50,100).lin(20,200).add(5)\nC3 = hv.Param.lin(1e-12, 10e-12, 10)\nsweep.add_dimension(C3)\nR1 = model.resistor(p1, n1, R1)\nR2 = model.resistor(n1, p2, R2)\nC = model.capacitor(n1, model.gnd, C3)\nf = hv.frange(1e6, 10e9,10_001)\nSs = []",
        "detail": "_old_python_files.sweep_test",
        "documentation": {}
    },
    {
        "label": "sweep",
        "kind": 5,
        "importPath": "_old_python_files.sweep_test",
        "description": "_old_python_files.sweep_test",
        "peekOfCode": "sweep = hv.ParameterSweep()\nR1, R2 = sweep.lin(50,100).lin(20,200).add(5)\nC3 = hv.Param.lin(1e-12, 10e-12, 10)\nsweep.add_dimension(C3)\nR1 = model.resistor(p1, n1, R1)\nR2 = model.resistor(n1, p2, R2)\nC = model.capacitor(n1, model.gnd, C3)\nf = hv.frange(1e6, 10e9,10_001)\nSs = []\nfor index in sweep.iterate():",
        "detail": "_old_python_files.sweep_test",
        "documentation": {}
    },
    {
        "label": "C3",
        "kind": 5,
        "importPath": "_old_python_files.sweep_test",
        "description": "_old_python_files.sweep_test",
        "peekOfCode": "C3 = hv.Param.lin(1e-12, 10e-12, 10)\nsweep.add_dimension(C3)\nR1 = model.resistor(p1, n1, R1)\nR2 = model.resistor(n1, p2, R2)\nC = model.capacitor(n1, model.gnd, C3)\nf = hv.frange(1e6, 10e9,10_001)\nSs = []\nfor index in sweep.iterate():\n    S = model.run_sparameter_analysis(f)\n    Ss.append(S.S21)",
        "detail": "_old_python_files.sweep_test",
        "documentation": {}
    },
    {
        "label": "R1",
        "kind": 5,
        "importPath": "_old_python_files.sweep_test",
        "description": "_old_python_files.sweep_test",
        "peekOfCode": "R1 = model.resistor(p1, n1, R1)\nR2 = model.resistor(n1, p2, R2)\nC = model.capacitor(n1, model.gnd, C3)\nf = hv.frange(1e6, 10e9,10_001)\nSs = []\nfor index in sweep.iterate():\n    S = model.run_sparameter_analysis(f)\n    Ss.append(S.S21)\nhv.plot_s_parameters(f, Ss)",
        "detail": "_old_python_files.sweep_test",
        "documentation": {}
    },
    {
        "label": "R2",
        "kind": 5,
        "importPath": "_old_python_files.sweep_test",
        "description": "_old_python_files.sweep_test",
        "peekOfCode": "R2 = model.resistor(n1, p2, R2)\nC = model.capacitor(n1, model.gnd, C3)\nf = hv.frange(1e6, 10e9,10_001)\nSs = []\nfor index in sweep.iterate():\n    S = model.run_sparameter_analysis(f)\n    Ss.append(S.S21)\nhv.plot_s_parameters(f, Ss)",
        "detail": "_old_python_files.sweep_test",
        "documentation": {}
    },
    {
        "label": "C",
        "kind": 5,
        "importPath": "_old_python_files.sweep_test",
        "description": "_old_python_files.sweep_test",
        "peekOfCode": "C = model.capacitor(n1, model.gnd, C3)\nf = hv.frange(1e6, 10e9,10_001)\nSs = []\nfor index in sweep.iterate():\n    S = model.run_sparameter_analysis(f)\n    Ss.append(S.S21)\nhv.plot_s_parameters(f, Ss)",
        "detail": "_old_python_files.sweep_test",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "_old_python_files.sweep_test",
        "description": "_old_python_files.sweep_test",
        "peekOfCode": "f = hv.frange(1e6, 10e9,10_001)\nSs = []\nfor index in sweep.iterate():\n    S = model.run_sparameter_analysis(f)\n    Ss.append(S.S21)\nhv.plot_s_parameters(f, Ss)",
        "detail": "_old_python_files.sweep_test",
        "documentation": {}
    },
    {
        "label": "Ss",
        "kind": 5,
        "importPath": "_old_python_files.sweep_test",
        "description": "_old_python_files.sweep_test",
        "peekOfCode": "Ss = []\nfor index in sweep.iterate():\n    S = model.run_sparameter_analysis(f)\n    Ss.append(S.S21)\nhv.plot_s_parameters(f, Ss)",
        "detail": "_old_python_files.sweep_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "_old_python_files.transmissionline_test",
        "description": "_old_python_files.transmissionline_test",
        "peekOfCode": "M = hv.Model()\nn1 = M.new_port(50)\nn2 = M.new_port(50)\nM.TL(n1,n2,lambda f: 2*np.pi*f/3e8, 0.2, 50)\nf = hv.frange(1e9, 10e9, 1001)\nS = M.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])",
        "detail": "_old_python_files.transmissionline_test",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "_old_python_files.transmissionline_test",
        "description": "_old_python_files.transmissionline_test",
        "peekOfCode": "n1 = M.new_port(50)\nn2 = M.new_port(50)\nM.TL(n1,n2,lambda f: 2*np.pi*f/3e8, 0.2, 50)\nf = hv.frange(1e9, 10e9, 1001)\nS = M.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])",
        "detail": "_old_python_files.transmissionline_test",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "_old_python_files.transmissionline_test",
        "description": "_old_python_files.transmissionline_test",
        "peekOfCode": "n2 = M.new_port(50)\nM.TL(n1,n2,lambda f: 2*np.pi*f/3e8, 0.2, 50)\nf = hv.frange(1e9, 10e9, 1001)\nS = M.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])",
        "detail": "_old_python_files.transmissionline_test",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "_old_python_files.transmissionline_test",
        "description": "_old_python_files.transmissionline_test",
        "peekOfCode": "f = hv.frange(1e9, 10e9, 1001)\nS = M.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])",
        "detail": "_old_python_files.transmissionline_test",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "_old_python_files.transmissionline_test",
        "description": "_old_python_files.transmissionline_test",
        "peekOfCode": "S = M.run(f)\nhv.plot_s_parameters(f, [S.S11, S.S21], labels=[\"S11\", \"S21\"], linestyles=[\"-\",\"-\"], colorcycle=[0,1])",
        "detail": "_old_python_files.transmissionline_test",
        "documentation": {}
    },
    {
        "label": "test_network",
        "kind": 2,
        "importPath": "_old_python_files.valid_test",
        "description": "_old_python_files.valid_test",
        "peekOfCode": "def test_network(net):\n    N = net.shape[0]\n    invalid = False\n    for q in range(1,N):\n        vc = np.zeros((N,))\n        vc[q] = 1\n        for _ in range(5):\n            vc = net @ vc\n        if vc[2]==0:\n            invalid=True",
        "detail": "_old_python_files.valid_test",
        "documentation": {}
    },
    {
        "label": "mm",
        "kind": 5,
        "importPath": "_old_python_files.z0_computation_test",
        "description": "_old_python_files.z0_computation_test",
        "peekOfCode": "mm = 0.001\nthickness = 0.5*mm\nZ0 = 50\ner = 4\nwidth_microstrip = pcb._w_from_z0_microstrip(Z0, thickness, er, 60e-6)\nprint(width_microstrip*1000)\nZ0new = pcb._microstrip_z0(width_microstrip, thickness, er, 60e-6)\nprint(Z0new)",
        "detail": "_old_python_files.z0_computation_test",
        "documentation": {}
    },
    {
        "label": "thickness",
        "kind": 5,
        "importPath": "_old_python_files.z0_computation_test",
        "description": "_old_python_files.z0_computation_test",
        "peekOfCode": "thickness = 0.5*mm\nZ0 = 50\ner = 4\nwidth_microstrip = pcb._w_from_z0_microstrip(Z0, thickness, er, 60e-6)\nprint(width_microstrip*1000)\nZ0new = pcb._microstrip_z0(width_microstrip, thickness, er, 60e-6)\nprint(Z0new)",
        "detail": "_old_python_files.z0_computation_test",
        "documentation": {}
    },
    {
        "label": "Z0",
        "kind": 5,
        "importPath": "_old_python_files.z0_computation_test",
        "description": "_old_python_files.z0_computation_test",
        "peekOfCode": "Z0 = 50\ner = 4\nwidth_microstrip = pcb._w_from_z0_microstrip(Z0, thickness, er, 60e-6)\nprint(width_microstrip*1000)\nZ0new = pcb._microstrip_z0(width_microstrip, thickness, er, 60e-6)\nprint(Z0new)",
        "detail": "_old_python_files.z0_computation_test",
        "documentation": {}
    },
    {
        "label": "er",
        "kind": 5,
        "importPath": "_old_python_files.z0_computation_test",
        "description": "_old_python_files.z0_computation_test",
        "peekOfCode": "er = 4\nwidth_microstrip = pcb._w_from_z0_microstrip(Z0, thickness, er, 60e-6)\nprint(width_microstrip*1000)\nZ0new = pcb._microstrip_z0(width_microstrip, thickness, er, 60e-6)\nprint(Z0new)",
        "detail": "_old_python_files.z0_computation_test",
        "documentation": {}
    },
    {
        "label": "width_microstrip",
        "kind": 5,
        "importPath": "_old_python_files.z0_computation_test",
        "description": "_old_python_files.z0_computation_test",
        "peekOfCode": "width_microstrip = pcb._w_from_z0_microstrip(Z0, thickness, er, 60e-6)\nprint(width_microstrip*1000)\nZ0new = pcb._microstrip_z0(width_microstrip, thickness, er, 60e-6)\nprint(Z0new)",
        "detail": "_old_python_files.z0_computation_test",
        "documentation": {}
    },
    {
        "label": "Z0new",
        "kind": 5,
        "importPath": "_old_python_files.z0_computation_test",
        "description": "_old_python_files.z0_computation_test",
        "peekOfCode": "Z0new = pcb._microstrip_z0(width_microstrip, thickness, er, 60e-6)\nprint(Z0new)",
        "detail": "_old_python_files.z0_computation_test",
        "documentation": {}
    },
    {
        "label": "PCBStack",
        "kind": 6,
        "importPath": "build.lib.heavi.lib.pcb",
        "description": "build.lib.heavi.lib.pcb",
        "peekOfCode": "class PCBStack:\n    def __init__(self, network: Network, epsilon_r: float, tand: float, thickness: float, Nlayers: int):\n        # Test that the layers are at least 2 and at most 10\n        if Nlayers < 2 or Nlayers > 10:\n            raise ValueError(\"The number of layers must be at least 2 and at most 10\")\n        # Test that the thickness is positive\n        if thickness <= 0:\n            raise ValueError(\"The thickness must be positive\")\n        # Test that the relative permittivity is positive\n        if epsilon_r <= 0:",
        "detail": "build.lib.heavi.lib.pcb",
        "documentation": {}
    },
    {
        "label": "coth",
        "kind": 2,
        "importPath": "build.lib.heavi.lib.pcb",
        "description": "build.lib.heavi.lib.pcb",
        "peekOfCode": "def coth(x):\n    return -np.tan(x + np.pi/2)\ndef _microstrip_ereff(w: float, h: float, er: float, t: float):\n    u = w/h\n    T = t/h\n    du1 = T/np.pi * np.log(1 + 4*np.exp(1)/(T*coth(6.517*u)**2))\n    dur = 1/2 * (1 + 1/np.cosh(er -1 )) * du1\n    u = u + dur\n    a = 1 + (1/49) * np.log((u**4 + (u/52)**2)/(u**4 + 0.432)) + (1/18.7) * np.log(1 + (u/18.1)**3)\n    b = 0.564 * ((er - 0.9) / (er + 3))**0.053",
        "detail": "build.lib.heavi.lib.pcb",
        "documentation": {}
    },
    {
        "label": "SMDResistorSize",
        "kind": 6,
        "importPath": "build.lib.heavi.lib.smd",
        "description": "build.lib.heavi.lib.smd",
        "peekOfCode": "class SMDResistorSize(Enum):\n    R0402 = \"0402\"\n    R0603 = \"0603\"\n    R0805 = \"0805\"\n    R1206 = \"1206\"\n    # Add other sizes as needed\nclass SMDCapacitorSize(Enum):\n    C0402 = \"0402\"\n    C0603 = \"0603\"\n    C0805 = \"0805\"",
        "detail": "build.lib.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "SMDCapacitorSize",
        "kind": 6,
        "importPath": "build.lib.heavi.lib.smd",
        "description": "build.lib.heavi.lib.smd",
        "peekOfCode": "class SMDCapacitorSize(Enum):\n    C0402 = \"0402\"\n    C0603 = \"0603\"\n    C0805 = \"0805\"\n    C1206 = \"1206\"\n    # Add other sizes as needed\nclass SMDInductorSize(Enum):\n    L0402 = \"0402\"\n    L0603 = \"0603\"\n    L0805 = \"0805\"",
        "detail": "build.lib.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "SMDInductorSize",
        "kind": 6,
        "importPath": "build.lib.heavi.lib.smd",
        "description": "build.lib.heavi.lib.smd",
        "peekOfCode": "class SMDInductorSize(Enum):\n    L0402 = \"0402\"\n    L0603 = \"0603\"\n    L0805 = \"0805\"\n    L1206 = \"1206\"\n    # Add other sizes as needed\nclass SMDResistor(BaseComponent):\n    \"\"\"\n    A simple SMD resistor model that accounts for parasitic inductance and capacitance \n    based on package size.",
        "detail": "build.lib.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "SMDResistor",
        "kind": 6,
        "importPath": "build.lib.heavi.lib.smd",
        "description": "build.lib.heavi.lib.smd",
        "peekOfCode": "class SMDResistor(BaseComponent):\n    \"\"\"\n    A simple SMD resistor model that accounts for parasitic inductance and capacitance \n    based on package size.\n    Attributes\n    ----------\n    resistance : float\n        The resistance value in ohms.\n    inductance : float\n        The parasitic inductance in henries.",
        "detail": "build.lib.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "SMDInductor",
        "kind": 6,
        "importPath": "build.lib.heavi.lib.smd",
        "description": "build.lib.heavi.lib.smd",
        "peekOfCode": "class SMDInductor(BaseComponent):\n    \"\"\"\n    An SMD inductor with a simple R-L // C parasitic model.\n    - The inductor has a series ESR (Equivalent Series Resistance) with the inductance.\n    - A small parallel capacitance accounts for high-frequency behavior.\n    Attributes\n    ----------\n    inductance : float\n        The nominal inductance value in henries (H).\n    esr : float",
        "detail": "build.lib.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "SMDCapacitor",
        "kind": 6,
        "importPath": "build.lib.heavi.lib.smd",
        "description": "build.lib.heavi.lib.smd",
        "peekOfCode": "class SMDCapacitor(BaseComponent):\n    \"\"\"\n    An SMD capacitor with an ESL-ESR-C series model.\n    Attributes\n    ----------\n    capacitance : float\n        The nominal capacitance value in farads (F).\n    esr : float\n        The equivalent series resistance in ohms ().\n    esl : float",
        "detail": "build.lib.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "BaseComponent",
        "kind": 6,
        "importPath": "build.lib.heavi.component",
        "description": "build.lib.heavi.component",
        "peekOfCode": "class BaseComponent:\n    def __init__(self):\n        self.network: Network = None\n        self.nodes: dict[int, Node] = {}\n        self.gnd: Node = None\n    def __validate__(self):\n        # Check if self.network is a Network object\n        if not isinstance(self.network, Network):\n            raise ValueError(\"The component must be connected to a Network object.\")\n        # Check if all nodes are Node objects with the same Network",
        "detail": "build.lib.heavi.component",
        "documentation": {}
    },
    {
        "label": "Router",
        "kind": 6,
        "importPath": "build.lib.heavi.design",
        "description": "build.lib.heavi.design",
        "peekOfCode": "class Router:\n    \"\"\"\n    The Router class is a utility class for quickly designing RF circuits.\n    It is designed to work with a Network object and provide a set of\n    common RF circuit design patterns.\n    Parameters:\n    -----------\n    N : Network\n        The Network object to build the circuit on.\n    er : float",
        "detail": "build.lib.heavi.design",
        "documentation": {}
    },
    {
        "label": "unbalanced_splitter",
        "kind": 2,
        "importPath": "build.lib.heavi.design",
        "description": "build.lib.heavi.design",
        "peekOfCode": "def unbalanced_splitter(N: Network, node: Node, Z0: float, f0: float, er: float = 1) -> List[Node]:\n    vg = 299792458/np.sqrt(er)\n    wl = vg / f0\n    n1 = N.node()\n    n2 = N.node()\n    Z02 = Z0*np.sqrt(2)\n    N.transmissionline(N.gnd, node, n1, Z02, er, wl/4)\n    N.transmissionline(N.gnd, node, n2, Z02, er, wl/4)\n    return [n1, n2]\ndef balanced_splitter(N: Network, node: Node, Z0: float, f0: float, er: float = 1) -> List[Node]:",
        "detail": "build.lib.heavi.design",
        "documentation": {}
    },
    {
        "label": "balanced_splitter",
        "kind": 2,
        "importPath": "build.lib.heavi.design",
        "description": "build.lib.heavi.design",
        "peekOfCode": "def balanced_splitter(N: Network, node: Node, Z0: float, f0: float, er: float = 1) -> List[Node]:\n    vg = 299792458/np.sqrt(er)\n    wl = vg / f0\n    n1 = N.node()\n    n2 = N.node()\n    Z02 = Z0*np.sqrt(2)\n    N.transmissionline(N.gnd, node, n1, Z02, er, wl/4)\n    N.transmissionline(N.gnd, node, n2, Z02, er, wl/4)\n    N.impedance(n1,n2,2*Z0)\n    return [n1, n2]",
        "detail": "build.lib.heavi.design",
        "documentation": {}
    },
    {
        "label": "FilterType",
        "kind": 6,
        "importPath": "build.lib.heavi.filtering",
        "description": "build.lib.heavi.filtering",
        "peekOfCode": "class FilterType(Enum):\n    CHEBYCHEV = 1\n    BUTTERWORTH = 2\nclass BandType(Enum):\n    HIGHPASS = 1\n    LOWPASS = 2\n    BANDPASS = 3\n    BANDSTOP = 4\nclass CauerType(Enum):\n    TYPE1 = 1",
        "detail": "build.lib.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "BandType",
        "kind": 6,
        "importPath": "build.lib.heavi.filtering",
        "description": "build.lib.heavi.filtering",
        "peekOfCode": "class BandType(Enum):\n    HIGHPASS = 1\n    LOWPASS = 2\n    BANDPASS = 3\n    BANDSTOP = 4\nclass CauerType(Enum):\n    TYPE1 = 1\n    TYPE2 = 2\nclass Filtering:\n    def __init__(self, N: Network):",
        "detail": "build.lib.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "CauerType",
        "kind": 6,
        "importPath": "build.lib.heavi.filtering",
        "description": "build.lib.heavi.filtering",
        "peekOfCode": "class CauerType(Enum):\n    TYPE1 = 1\n    TYPE2 = 2\nclass Filtering:\n    def __init__(self, N: Network):\n        self.N = N \n    def impedance_transformer(self,\n                              gnd: Node,\n                              port1: Node,\n                              port2: Node,",
        "detail": "build.lib.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "Filtering",
        "kind": 6,
        "importPath": "build.lib.heavi.filtering",
        "description": "build.lib.heavi.filtering",
        "peekOfCode": "class Filtering:\n    def __init__(self, N: Network):\n        self.N = N \n    def impedance_transformer(self,\n                              gnd: Node,\n                              port1: Node,\n                              port2: Node,\n                              Z01: float,\n                              Z02: float,\n                              fc: float = None,",
        "detail": "build.lib.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "even",
        "kind": 2,
        "importPath": "build.lib.heavi.filtering",
        "description": "build.lib.heavi.filtering",
        "peekOfCode": "def even(x):\n    \"\"\" Returns True if x is even, False otherwise. \"\"\"\n    if x % 2 == 0:\n        return True\n    return False\ndef odd(x):\n    \"\"\" Returns True if x is odd, False otherwise. \"\"\"\n    if x % 2 == 1:\n        return True\n    return False",
        "detail": "build.lib.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "odd",
        "kind": 2,
        "importPath": "build.lib.heavi.filtering",
        "description": "build.lib.heavi.filtering",
        "peekOfCode": "def odd(x):\n    \"\"\" Returns True if x is odd, False otherwise. \"\"\"\n    if x % 2 == 1:\n        return True\n    return False\nclass FilterType(Enum):\n    CHEBYCHEV = 1\n    BUTTERWORTH = 2\nclass BandType(Enum):\n    HIGHPASS = 1",
        "detail": "build.lib.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "prototype_chebychev",
        "kind": 2,
        "importPath": "build.lib.heavi.filtering",
        "description": "build.lib.heavi.filtering",
        "peekOfCode": "def prototype_chebychev(order, ripple):\n    N = order\n    # if order % 2 == 0:\n    #    N = N + 1\n    # one extra because the chebychev needs a zeroth element\n    Gk = [i for i in range(N + 2)]\n    Ak = [i for i in range(N + 2)]\n    Bk = [i for i in range(N + 2)]\n    B = np.log(1 / np.tanh(ripple * np.log(10) / 40))\n    y = np.sinh(B / (2 * N))",
        "detail": "build.lib.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "prototype_butterworth",
        "kind": 2,
        "importPath": "build.lib.heavi.filtering",
        "description": "build.lib.heavi.filtering",
        "peekOfCode": "def prototype_butterworth(order):\n    N = order\n    # if order % 2 == 0:\n    #    N = N + 1\n    Gk = [i + 1 for i in range(N)]\n    for i in Gk:\n        Gk[i - 1] = 2 * np.sin(np.pi * (2 * i - 1) / (2 * N))\n    return Gk, 1",
        "detail": "build.lib.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "hintersections",
        "kind": 2,
        "importPath": "build.lib.heavi.graphing",
        "description": "build.lib.heavi.graphing",
        "peekOfCode": "def hintersections(x, y, level):\n    y1 = y[:-1] - level\n    y2 = y[1:] - level\n    ycross = y1 * y2\n    id1 = np.where(ycross < 0)[0]\n    id2 = id1 + 1\n    x1 = x[id1]\n    x2 = x[id2]\n    y1 = y[id1] - level\n    y2 = y[id2] - level",
        "detail": "build.lib.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "plot",
        "kind": 2,
        "importPath": "build.lib.heavi.graphing",
        "description": "build.lib.heavi.graphing",
        "peekOfCode": "def plot(x, y):\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    ax.grid()\n    plt.show()\ndef smithplotSparam(f, S):\n    pass\ndef plot_s_parameters(f, S, dblim=[-80, 5], \n               xunit=\"GHz\", \n               levelindicator: int | float =None, ",
        "detail": "build.lib.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "smithplotSparam",
        "kind": 2,
        "importPath": "build.lib.heavi.graphing",
        "description": "build.lib.heavi.graphing",
        "peekOfCode": "def smithplotSparam(f, S):\n    pass\ndef plot_s_parameters(f, S, dblim=[-80, 5], \n               xunit=\"GHz\", \n               levelindicator: int | float =None, \n               noise_floor=-150, \n               fill_areas: list[tuple]= None, \n               unwrap_phase=False, \n               logx: bool = False,\n               labels: list[str] = None,",
        "detail": "build.lib.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "plot_s_parameters",
        "kind": 2,
        "importPath": "build.lib.heavi.graphing",
        "description": "build.lib.heavi.graphing",
        "peekOfCode": "def plot_s_parameters(f, S, dblim=[-80, 5], \n               xunit=\"GHz\", \n               levelindicator: int | float =None, \n               noise_floor=-150, \n               fill_areas: list[tuple]= None, \n               unwrap_phase=False, \n               logx: bool = False,\n               labels: list[str] = None,\n               linestyles: list[str] = None,\n               colorcycle: list[int] = None):",
        "detail": "build.lib.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "plotSparam_OLD",
        "kind": 2,
        "importPath": "build.lib.heavi.graphing",
        "description": "build.lib.heavi.graphing",
        "peekOfCode": "def plotSparam_OLD(f, S, dblim=[-80, 5], xunit=\"GHz\", levelindicator=False, noise_floor=-90):\n    if not isinstance(S, list):\n        Ss = [S]\n    else:\n        Ss = S\n    unitdivider = {\"MHz\": 1e6, \"GHz\": 1e9, \"kHz\": 1e3}\n    fnew = f / unitdivider[xunit]\n    fig, ax = plt.subplots()\n    for s in Ss:\n        SdB = 20 * np.log10(np.abs(s)+10**(noise_floor/20)*np.random.rand(*s.shape)+10**((noise_floor-30)/20))",
        "detail": "build.lib.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "histogram",
        "kind": 2,
        "importPath": "build.lib.heavi.graphing",
        "description": "build.lib.heavi.graphing",
        "peekOfCode": "def histogram(data, nbins=20):\n    n, bins, patches = plt.hist(data, nbins, density=True, facecolor=\"g\", alpha=0.75)\n    print(n, bins, patches)\n    plt.xlabel(\"Values\")\n    plt.ylabel(\"Probability\")\n    # plt.text(60, .025, r'$\\mu=100,\\ \\sigma=15$')\n    # plt.xlim(40, 160)\n    # plt.ylim(0, 0.03)\n    plt.grid(True)\n    plt.show()",
        "detail": "build.lib.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "_colors",
        "kind": 5,
        "importPath": "build.lib.heavi.graphing",
        "description": "build.lib.heavi.graphing",
        "peekOfCode": "_colors = plt.rcParams['axes.prop_cycle'].by_key()['color']\nggplot_styles = {\n    \"axes.edgecolor\": \"000000\",\n    \"axes.facecolor\": \"F2F2F2\",\n    \"axes.grid\": True,\n    \"axes.grid.which\": \"both\",\n    \"axes.spines.left\": True,\n    \"axes.spines.right\": True,\n    \"axes.spines.top\": True,\n    \"axes.spines.bottom\": True,",
        "detail": "build.lib.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "ggplot_styles",
        "kind": 5,
        "importPath": "build.lib.heavi.graphing",
        "description": "build.lib.heavi.graphing",
        "peekOfCode": "ggplot_styles = {\n    \"axes.edgecolor\": \"000000\",\n    \"axes.facecolor\": \"F2F2F2\",\n    \"axes.grid\": True,\n    \"axes.grid.which\": \"both\",\n    \"axes.spines.left\": True,\n    \"axes.spines.right\": True,\n    \"axes.spines.top\": True,\n    \"axes.spines.bottom\": True,\n    \"grid.color\": \"A0A0A0\",",
        "detail": "build.lib.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "Library",
        "kind": 6,
        "importPath": "build.lib.heavi.library",
        "description": "build.lib.heavi.library",
        "peekOfCode": "class Library:\n    \"\"\" \n    The Library class extends the standard Network class with a set of\n    predefined or higher-order definitions of common components (R, L, C, etc.).\n    The methods in this class leverage `network.impedance(...)` to build up\n    custom frequency-dependent or compound component models.\n    \"\"\"\n    def __init__(self, N: Network):\n        self.N = N\n    # ------------------------------------------------------------------------",
        "detail": "build.lib.heavi.library",
        "documentation": {}
    },
    {
        "label": "c0",
        "kind": 5,
        "importPath": "build.lib.heavi.library",
        "description": "build.lib.heavi.library",
        "peekOfCode": "c0 = 299792458\nclass Library:\n    \"\"\" \n    The Library class extends the standard Network class with a set of\n    predefined or higher-order definitions of common components (R, L, C, etc.).\n    The methods in this class leverage `network.impedance(...)` to build up\n    custom frequency-dependent or compound component models.\n    \"\"\"\n    def __init__(self, N: Network):\n        self.N = N",
        "detail": "build.lib.heavi.library",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 6,
        "importPath": "build.lib.heavi.model",
        "description": "build.lib.heavi.model",
        "peekOfCode": "class Model(Network):\n    def __init__(self, default_name: str = \"Node\", \n                 filter_library: Filtering = Filtering, \n                 component_library: Library = Library,\n                 suppress_loadbar: bool = False):\n        super().__init__(default_name, suppress_loadbar=suppress_loadbar)\n        self.filters: Filtering = filter_library(self)\n        self.lib: Library = component_library(self)",
        "detail": "build.lib.heavi.model",
        "documentation": {}
    },
    {
        "label": "Uninitialized",
        "kind": 6,
        "importPath": "build.lib.heavi.numeric",
        "description": "build.lib.heavi.numeric",
        "peekOfCode": "class Uninitialized:\n    def __init__(self):\n        pass\n    def __repr__(self):\n        return \"Uninitialized\"\n    def __call__(self, f):\n        raise ValueError(\"Uninitialized value\")\n    def __mul__(self, other):\n        raise ValueError(\"Uninitialized value\")\n    def __add__(self, other):",
        "detail": "build.lib.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "SimValue",
        "kind": 6,
        "importPath": "build.lib.heavi.numeric",
        "description": "build.lib.heavi.numeric",
        "peekOfCode": "class SimValue:\n    def __init__(self, value: float):\n        self._value = value\n    @property\n    def value(self) -> float:\n        return self(1)\n    def scalar(self) -> float:\n        return self(1)\n    def initialize(self) -> None:\n        pass",
        "detail": "build.lib.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Negative",
        "kind": 6,
        "importPath": "build.lib.heavi.numeric",
        "description": "build.lib.heavi.numeric",
        "peekOfCode": "class Negative(SimValue):\n    def __init__(self, value: SimValue):\n        self._value: SimValue = value\n    def __repr__(self) -> str:\n        return f\"Negative({self._value})\"\n    def __call__(self, f: np.ndarray) -> np.ndarray:\n        return -self._value(f)\n    def negative(self) -> SimValue:\n        return self._value\nclass Inverse(SimValue):",
        "detail": "build.lib.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Inverse",
        "kind": 6,
        "importPath": "build.lib.heavi.numeric",
        "description": "build.lib.heavi.numeric",
        "peekOfCode": "class Inverse(SimValue):\n    def __init__(self, value: SimValue):\n        self._value: SimValue = value\n    def __repr__(self) -> str:\n        return f\"Inverse({self._value})\"\n    def __call__(self, f: np.ndarray) -> np.ndarray:\n        return 1/self._value(f)\n    def negative(self) -> SimValue:\n        return Negative(self)\n    def inverse(self) -> SimValue:",
        "detail": "build.lib.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Function",
        "kind": 6,
        "importPath": "build.lib.heavi.numeric",
        "description": "build.lib.heavi.numeric",
        "peekOfCode": "class Function(SimValue):\n    def __init__(self, function: Callable[[np.ndarray], np.ndarray]):\n        self._function = function\n    def __repr__(self) -> str:\n        return f\"Function({self._function})\"\n    def __call__(self, f: np.ndarray) -> np.ndarray:\n        return self._function(f)\n    def negative(self) -> SimValue:\n        return Function(lambda f: -self._function(f))\n    def inverse(self) -> SimValue:",
        "detail": "build.lib.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Random",
        "kind": 6,
        "importPath": "build.lib.heavi.numeric",
        "description": "build.lib.heavi.numeric",
        "peekOfCode": "class Random(SimValue):\n    def __init__(self, randomizer: Callable):\n        self._randomizer = randomizer\n        self._value = Uninitialized()\n    def initialize(self):\n        self._value = self._randomizer()\n    def __repr__(self):\n        return f\"Gaussian({self._mean}, {self._std})\"   \n    def __call__(self, f):\n        return self._value * np.ones_like(f)",
        "detail": "build.lib.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Param",
        "kind": 6,
        "importPath": "build.lib.heavi.numeric",
        "description": "build.lib.heavi.numeric",
        "peekOfCode": "class Param(SimValue):\n    def __init__(self, values: np.ndarray):\n        self._values = values\n        self._index: int = 0\n        self._value = Uninitialized()\n    @staticmethod\n    def lin(start: float, stop: float, Nsteps: int) -> Param:\n        return Param(np.linspace(start,stop,Nsteps))\n    @staticmethod\n    def range(start: float, stop: float, step: float, *args, **kwargs) -> Param:",
        "detail": "build.lib.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "ParameterSweep",
        "kind": 6,
        "importPath": "build.lib.heavi.numeric",
        "description": "build.lib.heavi.numeric",
        "peekOfCode": "class ParameterSweep:\n    def __init__(self):\n        self.sweep_dimensions: list[tuple[Param]] = []\n        self.index_series: list[tuple[int]] = []\n        self._index: int = 0\n        self._param_buffer: list = []\n    def lin(self, start: float, stop: float) -> ParameterSweep:\n        self._param_buffer.append((start,None,stop))\n        return self\n    def step(self, start: float, stepsize: float) -> ParameterSweep:",
        "detail": "build.lib.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "MonteCarlo",
        "kind": 6,
        "importPath": "build.lib.heavi.numeric",
        "description": "build.lib.heavi.numeric",
        "peekOfCode": "class MonteCarlo:\n    def __init__(self):\n        self._random_numbers: list[Random] = []\n    def gaussian(self, mean: float, std: float) -> Random:\n        random = Random(lambda: np.random.normal(mean, std))\n        self._random_numbers.append(random)\n        return random\n    def uniform(self, low: float, high: float) -> Random:\n        random = Random(lambda: np.random.uniform(low, high))\n        self._random_numbers.append(random)",
        "detail": "build.lib.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "parse_numeric",
        "kind": 2,
        "importPath": "build.lib.heavi.numeric",
        "description": "build.lib.heavi.numeric",
        "peekOfCode": "def parse_numeric(value: float | SimValue | Callable, inverse: bool = False) -> SimValue:\n    if isinstance(value, SimValue):\n        if inverse:\n            return value.inverse()\n        return value\n    elif isinstance(value, Callable):\n        if inverse:\n            return Function(lambda f: 1/value(f))\n        return Function(value)\n    elif isinstance(value, (int, float, complex)):",
        "detail": "build.lib.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "ComponentType",
        "kind": 6,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "class ComponentType(Enum):\n    UNDEFINED = 0\n    RESISTOR = 1\n    CAPACITOR = 2\n    INDUCTOR = 3\n    CURRENTSOURCE = 4\n    VOLTAGESOURCE = 5\n    IMPEDANCE = 6\n    ADMITTANCE = 7\n    TRANSMISSIONLINE = 8",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "class Node:\n    \"\"\" Node class for the Network object. \"\"\"\n    name: str\n    index: int = None\n    _parent: Network = None\n    def __hash__(self):\n        return hash(f'{self.name}_{self.index}')\n@dataclass\nclass ComponentFunction:\n    \"\"\" ComponentFunction class for the Component object. \"\"\"",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "ComponentFunction",
        "kind": 6,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "class ComponentFunction:\n    \"\"\" ComponentFunction class for the Component object. \"\"\"\n    node_list: list[Node]\n    simval: SimValue\n    as_matrix: bool = False\n    @property\n    def matrix_slice(self) -> tuple:\n        \"\"\" Returns a tuple of slices for the matrix indices corresponding to the nodes. \"\"\"\n        if self.as_matrix:\n            idx = [node.index for node in self.node_list]",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Component",
        "kind": 6,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "class Component:\n    \"\"\" Component class for the Network object. \n    This class represents a component in the network, such as a resistor, capacitor, inductor, etc.\n    Parameters\n    ----------\n    nodes : list[Node]\n        A list of Node objects corresponding to the nodes the component is connected to.\n    functionlist : list[ComponentFunction]\n        A list of ComponentFunction objects corresponding to the functions of the component.\n    type : ComponentType",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Terminal",
        "kind": 6,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "class Terminal:\n    ground: Node\n    port: Node\n    source: Component\n    source_impedance: Component\n    @property\n    def ground_node(self) -> Node:\n        return self.source.nodes\n    @property\n    def z_source(self) -> SimValue:",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Network",
        "kind": 6,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "class Network:\n    \"\"\" Network class for the Network object.\n    This class represents a network of components and nodes. It is used to build and analyze circuits.\n    Parameters\n    ----------\n    default_name : str\n        The default name for a node.\n    node_name_counter_start : int\n        The starting index for the node name counter.\n    \"\"\"",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Z0_VSWR",
        "kind": 2,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "def Z0_VSWR(Z0: float, max_vswr: float) -> float:\n    \"\"\"\n    Returns a random real impedance corresponding to a random VSWR between 1\n    and max_vswr relative to the reference impedance Z0.\n    Parameters\n    ----------\n    Z0 : float\n        The reference impedance (Ohms).\n    max_vswr : float\n        The maximum possible VSWR.",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "randphase",
        "kind": 2,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "def randphase():\n    \"\"\" Returns a complex number with a random phase. \"\"\"\n    return np.exp(complex(0, 2 * np.pi * np.random.random_sample()))\ndef randmag(minv, maxv):\n    \"\"\" Returns a random number between minv and maxv. \"\"\"\n    return (maxv - minv) * np.random.random_sample() + minv\ndef randomphasor(minv=0, maxv=1):\n    \"\"\" Returns a random complex number with a random phase and magnitude. \"\"\"\n    return randmag(minv, maxv) * randphase()\ndef _make_callable(value: float | complex | Callable) -> Callable:",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "randmag",
        "kind": 2,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "def randmag(minv, maxv):\n    \"\"\" Returns a random number between minv and maxv. \"\"\"\n    return (maxv - minv) * np.random.random_sample() + minv\ndef randomphasor(minv=0, maxv=1):\n    \"\"\" Returns a random complex number with a random phase and magnitude. \"\"\"\n    return randmag(minv, maxv) * randphase()\ndef _make_callable(value: float | complex | Callable) -> Callable:\n    \"\"\" Returns a callable function for a given value. \"\"\"\n    if isinstance(value, Callable):\n        return value",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "randomphasor",
        "kind": 2,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "def randomphasor(minv=0, maxv=1):\n    \"\"\" Returns a random complex number with a random phase and magnitude. \"\"\"\n    return randmag(minv, maxv) * randphase()\ndef _make_callable(value: float | complex | Callable) -> Callable:\n    \"\"\" Returns a callable function for a given value. \"\"\"\n    if isinstance(value, Callable):\n        return value\n    else:\n        return lambda f: value*np.ones_like(f)\n@njit(cache=True, parallel=True, fastmath=True)",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "solve_single_frequency_c_compiled",
        "kind": 2,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "def solve_single_frequency_c_compiled(Is, Ys, Zs, indices, frequencies, progprox):\n    nT = len(indices)\n    nF = len(frequencies)\n    Ss = np.zeros((nT,nT,nF), dtype=np.complex128)\n    Vdonor = np.zeros((Is.shape[0],), dtype=np.complex128)\n    for it in range(nT):\n        ind1 = indices[it]\n        for i in prange(nF):\n            Vh = 0*Vdonor\n            Vh[1:] = np.linalg.solve(Ys[:,:,i],Is[1:,it,i])",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "compute_s_parameters",
        "kind": 2,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "def compute_s_parameters(Is, Ys, Zs, port_indices, frequencies, progress_object):\n    \"\"\"\n    Compute the S-parameter matrix for an RF network using Numba for acceleration.\n    Parameters\n    ----------\n    Is : numpy.ndarray\n        Current sources, complex-valued array of shape (n_nodes, n_ports, n_freqs).\n    Ys : numpy.ndarray\n        Admittance matrices, complex-valued array of shape (n_nodes, n_nodes, n_freqs).\n    Zs : numpy.ndarray",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "compute_s_parameters_no_loadbar",
        "kind": 2,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "def compute_s_parameters_no_loadbar(Is, Ys, Zs, port_indices, frequencies):\n    \"\"\"\n    Compute the S-parameter matrix for an RF network using Numba for acceleration.\n    Parameters\n    ----------\n    Is : numpy.ndarray\n        Current sources, complex-valued array of shape (n_nodes, n_ports, n_freqs).\n    Ys : numpy.ndarray\n        Admittance matrices, complex-valued array of shape (n_nodes, n_nodes, n_freqs).\n    Zs : numpy.ndarray",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "TEN_POWERS",
        "kind": 5,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "TEN_POWERS = {\n    -12: \"p\",\n    -9: \"n\",\n    -6: \"u\",\n    -3: \"m\",\n    0: \"\",\n    3: \"k\",\n    6: \"M\",\n    9: \"T\",\n    12: \"P\",",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "twopi",
        "kind": 5,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "twopi = 2 * np.pi\npi = np.pi\ndef randphase():\n    \"\"\" Returns a complex number with a random phase. \"\"\"\n    return np.exp(complex(0, 2 * np.pi * np.random.random_sample()))\ndef randmag(minv, maxv):\n    \"\"\" Returns a random number between minv and maxv. \"\"\"\n    return (maxv - minv) * np.random.random_sample() + minv\ndef randomphasor(minv=0, maxv=1):\n    \"\"\" Returns a random complex number with a random phase and magnitude. \"\"\"",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "pi",
        "kind": 5,
        "importPath": "build.lib.heavi.rfcircuit",
        "description": "build.lib.heavi.rfcircuit",
        "peekOfCode": "pi = np.pi\ndef randphase():\n    \"\"\" Returns a complex number with a random phase. \"\"\"\n    return np.exp(complex(0, 2 * np.pi * np.random.random_sample()))\ndef randmag(minv, maxv):\n    \"\"\" Returns a random number between minv and maxv. \"\"\"\n    return (maxv - minv) * np.random.random_sample() + minv\ndef randomphasor(minv=0, maxv=1):\n    \"\"\" Returns a random complex number with a random phase and magnitude. \"\"\"\n    return randmag(minv, maxv) * randphase()",
        "detail": "build.lib.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Router",
        "kind": 6,
        "importPath": "build.lib.heavi.routing",
        "description": "build.lib.heavi.routing",
        "peekOfCode": "class Router:\n    \"\"\"\n    The Router class is a utility class for quickly designing RF circuits.\n    It is designed to work with a Network object and provide a set of\n    common RF circuit design patterns.\n    Parameters:\n    -----------\n    N : Network\n        The Network object to build the circuit on.\n    er : float",
        "detail": "build.lib.heavi.routing",
        "documentation": {}
    },
    {
        "label": "unbalanced_splitter",
        "kind": 2,
        "importPath": "build.lib.heavi.routing",
        "description": "build.lib.heavi.routing",
        "peekOfCode": "def unbalanced_splitter(N: Network, node: Node, Z0: float, f0: float, er: float = 1) -> List[Node]:\n    vg = 299792458/np.sqrt(er)\n    wl = vg / f0\n    n1 = N.node()\n    n2 = N.node()\n    Z02 = Z0*np.sqrt(2)\n    N.transmissionline(N.gnd, node, n1, Z02, er, wl/4)\n    N.transmissionline(N.gnd, node, n2, Z02, er, wl/4)\n    return [n1, n2]\ndef balanced_splitter(N: Network, node: Node, Z0: float, f0: float, er: float = 1) -> List[Node]:",
        "detail": "build.lib.heavi.routing",
        "documentation": {}
    },
    {
        "label": "balanced_splitter",
        "kind": 2,
        "importPath": "build.lib.heavi.routing",
        "description": "build.lib.heavi.routing",
        "peekOfCode": "def balanced_splitter(N: Network, node: Node, Z0: float, f0: float, er: float = 1) -> List[Node]:\n    vg = 299792458/np.sqrt(er)\n    wl = vg / f0\n    n1 = N.node()\n    n2 = N.node()\n    Z02 = Z0*np.sqrt(2)\n    N.transmissionline(N.gnd, node, n1, Z02, er, wl/4)\n    N.transmissionline(N.gnd, node, n2, Z02, er, wl/4)\n    N.impedance(n1,n2,2*Z0)\n    return [n1, n2]",
        "detail": "build.lib.heavi.routing",
        "documentation": {}
    },
    {
        "label": "Settings",
        "kind": 6,
        "importPath": "build.lib.heavi.settings",
        "description": "build.lib.heavi.settings",
        "peekOfCode": "class Settings:\n    def __init__(self):\n        self.verbose = True\nSETTINGS = Settings()",
        "detail": "build.lib.heavi.settings",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "kind": 5,
        "importPath": "build.lib.heavi.settings",
        "description": "build.lib.heavi.settings",
        "peekOfCode": "SETTINGS = Settings()",
        "detail": "build.lib.heavi.settings",
        "documentation": {}
    },
    {
        "label": "Sparameters",
        "kind": 6,
        "importPath": "build.lib.heavi.sparam",
        "description": "build.lib.heavi.sparam",
        "peekOfCode": "class Sparameters:\n    def __init__(self, S: np.ndarray, f: np.ndarray):\n        \"\"\" S-parameters object\n        Parameters\n        ----------\n        S : np.ndarray\n            Scattering matrix of shape (nports, nports, nfreqs)\"\"\"\n        self._S = S\n        self.f = f\n        self.nports = S.shape[0]",
        "detail": "build.lib.heavi.sparam",
        "documentation": {}
    },
    {
        "label": "frange",
        "kind": 2,
        "importPath": "build.lib.heavi.sparam",
        "description": "build.lib.heavi.sparam",
        "peekOfCode": "def frange(fmin: float, fmax: float, n: int) -> np.ndarray:\n    \"\"\"Generate n frequencies from fmin to fmax\"\"\"\n    return np.linspace(fmin, fmax, n)\nclass Sparameters:\n    def __init__(self, S: np.ndarray, f: np.ndarray):\n        \"\"\" S-parameters object\n        Parameters\n        ----------\n        S : np.ndarray\n            Scattering matrix of shape (nports, nports, nfreqs)\"\"\"",
        "detail": "build.lib.heavi.sparam",
        "documentation": {}
    },
    {
        "label": "analyse_sparameter",
        "kind": 2,
        "importPath": "build.lib.heavi.stochastic",
        "description": "build.lib.heavi.stochastic",
        "peekOfCode": "def analyse_sparameter(sparam: list[np.ndarray], sparam_phase: list[np.ndarray], phase_reference: np.ndarray=None, n_bins: int = 51) -> tuple[tuple[float, float], tuple[float, float]]:\n    \"\"\"\n    Analyse a set of S-parameter arrays, returning amplitude (dB) and phase statistics\n    and plotting their histograms (PDF) and cumulative distributions (CDF), each on a\n    separate y-axis.\n    Parameters\n    ----------\n    sparam : list of np.ndarray\n        Each element is a complex-valued S-parameter array (e.g. shape (F,)).\n        We flatten them over frequency.",
        "detail": "build.lib.heavi.stochastic",
        "documentation": {}
    },
    {
        "label": "Param",
        "kind": 6,
        "importPath": "build.lib.heavi.system",
        "description": "build.lib.heavi.system",
        "peekOfCode": "class Param:\n    value: float = None\n    def __post_init__(self):\n        if isinstance(self.value, float):\n            self.get = lambda: self.value\n        elif isinstance(self.value, (list, tuple):\n            self.get = lambda: random() * (max(self.value)-min(self.value) + min(self.value)\nclass SystemPart:\n    def __init__(self, factory: Callable, arguments: dict):\n        self._factory = factory",
        "detail": "build.lib.heavi.system",
        "documentation": {}
    },
    {
        "label": "SystemPart",
        "kind": 6,
        "importPath": "build.lib.heavi.system",
        "description": "build.lib.heavi.system",
        "peekOfCode": "class SystemPart:\n    def __init__(self, factory: Callable, arguments: dict):\n        self._factory = factory\n        self._args = arguments\n    def _compile(self, node1: Node, node2: Node):\n        kwargs = {x, self._args[x].get() for x in self._args}\n        self._factory(node1, node2, **kwargs)\nclass System:\n    def __init__(self, Z0: complex = 50):\n        self.network = Network()",
        "detail": "build.lib.heavi.system",
        "documentation": {}
    },
    {
        "label": "System",
        "kind": 6,
        "importPath": "build.lib.heavi.system",
        "description": "build.lib.heavi.system",
        "peekOfCode": "class System:\n    def __init__(self, Z0: complex = 50):\n        self.network = Network()\n        self._gnd = self.network.gnd\n        self._nin = self.network.node(\"vp1\")\n        self._nout = self.network.node(\"vp2\")\n        self._z0 = 50\n        self._p1 = self.network.terminal(self._gnd, self._nin, self._z0)\n        self._p2 = self.network.terminal(self._gnd, self._nout, self._z0)\n        self._components = list()",
        "detail": "build.lib.heavi.system",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "dev_scripts.DC_test",
        "description": "dev_scripts.DC_test",
        "peekOfCode": "M = hv.Model()\nnode_in = M.node()\ndc1 = M.DC_source(node_in, 1.0)\nn1 = M.node()\nL = M.inductor(node_in, n1, 1e-6)\nn2 = M.node()\nR1 = M.resistor(n2, n1, 100)\nR2 = M.resistor(M.gnd, n2, 200)\nL = M.inductor(n1, M.gnd, 1e-6)\nV = M.run_dc()",
        "detail": "dev_scripts.DC_test",
        "documentation": {}
    },
    {
        "label": "node_in",
        "kind": 5,
        "importPath": "dev_scripts.DC_test",
        "description": "dev_scripts.DC_test",
        "peekOfCode": "node_in = M.node()\ndc1 = M.DC_source(node_in, 1.0)\nn1 = M.node()\nL = M.inductor(node_in, n1, 1e-6)\nn2 = M.node()\nR1 = M.resistor(n2, n1, 100)\nR2 = M.resistor(M.gnd, n2, 200)\nL = M.inductor(n1, M.gnd, 1e-6)\nV = M.run_dc()\nprint(V)",
        "detail": "dev_scripts.DC_test",
        "documentation": {}
    },
    {
        "label": "dc1",
        "kind": 5,
        "importPath": "dev_scripts.DC_test",
        "description": "dev_scripts.DC_test",
        "peekOfCode": "dc1 = M.DC_source(node_in, 1.0)\nn1 = M.node()\nL = M.inductor(node_in, n1, 1e-6)\nn2 = M.node()\nR1 = M.resistor(n2, n1, 100)\nR2 = M.resistor(M.gnd, n2, 200)\nL = M.inductor(n1, M.gnd, 1e-6)\nV = M.run_dc()\nprint(V)",
        "detail": "dev_scripts.DC_test",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "dev_scripts.DC_test",
        "description": "dev_scripts.DC_test",
        "peekOfCode": "n1 = M.node()\nL = M.inductor(node_in, n1, 1e-6)\nn2 = M.node()\nR1 = M.resistor(n2, n1, 100)\nR2 = M.resistor(M.gnd, n2, 200)\nL = M.inductor(n1, M.gnd, 1e-6)\nV = M.run_dc()\nprint(V)",
        "detail": "dev_scripts.DC_test",
        "documentation": {}
    },
    {
        "label": "L",
        "kind": 5,
        "importPath": "dev_scripts.DC_test",
        "description": "dev_scripts.DC_test",
        "peekOfCode": "L = M.inductor(node_in, n1, 1e-6)\nn2 = M.node()\nR1 = M.resistor(n2, n1, 100)\nR2 = M.resistor(M.gnd, n2, 200)\nL = M.inductor(n1, M.gnd, 1e-6)\nV = M.run_dc()\nprint(V)",
        "detail": "dev_scripts.DC_test",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "dev_scripts.DC_test",
        "description": "dev_scripts.DC_test",
        "peekOfCode": "n2 = M.node()\nR1 = M.resistor(n2, n1, 100)\nR2 = M.resistor(M.gnd, n2, 200)\nL = M.inductor(n1, M.gnd, 1e-6)\nV = M.run_dc()\nprint(V)",
        "detail": "dev_scripts.DC_test",
        "documentation": {}
    },
    {
        "label": "R1",
        "kind": 5,
        "importPath": "dev_scripts.DC_test",
        "description": "dev_scripts.DC_test",
        "peekOfCode": "R1 = M.resistor(n2, n1, 100)\nR2 = M.resistor(M.gnd, n2, 200)\nL = M.inductor(n1, M.gnd, 1e-6)\nV = M.run_dc()\nprint(V)",
        "detail": "dev_scripts.DC_test",
        "documentation": {}
    },
    {
        "label": "R2",
        "kind": 5,
        "importPath": "dev_scripts.DC_test",
        "description": "dev_scripts.DC_test",
        "peekOfCode": "R2 = M.resistor(M.gnd, n2, 200)\nL = M.inductor(n1, M.gnd, 1e-6)\nV = M.run_dc()\nprint(V)",
        "detail": "dev_scripts.DC_test",
        "documentation": {}
    },
    {
        "label": "L",
        "kind": 5,
        "importPath": "dev_scripts.DC_test",
        "description": "dev_scripts.DC_test",
        "peekOfCode": "L = M.inductor(n1, M.gnd, 1e-6)\nV = M.run_dc()\nprint(V)",
        "detail": "dev_scripts.DC_test",
        "documentation": {}
    },
    {
        "label": "V",
        "kind": 5,
        "importPath": "dev_scripts.DC_test",
        "description": "dev_scripts.DC_test",
        "peekOfCode": "V = M.run_dc()\nprint(V)",
        "detail": "dev_scripts.DC_test",
        "documentation": {}
    },
    {
        "label": "G1",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "G1 = 1/50\nG2 = 1/200\nG3 = 1/50\nA = np.zeros((6,6))\nG = np.array([[0, 0, -G2, 0],[0, 0, -G1, 0],[-G2, -G1, 0, -G3],[0, 0, -G3, 0]])\nmerge_nodes = [(3,0),]\nto_remove = [a for a,b in merge_nodes]\nids = [i for i in range(A.shape[0]) if i not in to_remove]\nz = np.array([0, 0, 0, 0, 1, 0])\n# print(G)",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "G2",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "G2 = 1/200\nG3 = 1/50\nA = np.zeros((6,6))\nG = np.array([[0, 0, -G2, 0],[0, 0, -G1, 0],[-G2, -G1, 0, -G3],[0, 0, -G3, 0]])\nmerge_nodes = [(3,0),]\nto_remove = [a for a,b in merge_nodes]\nids = [i for i in range(A.shape[0]) if i not in to_remove]\nz = np.array([0, 0, 0, 0, 1, 0])\n# print(G)\n# for na, nb in merge_nodes:",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "G3",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "G3 = 1/50\nA = np.zeros((6,6))\nG = np.array([[0, 0, -G2, 0],[0, 0, -G1, 0],[-G2, -G1, 0, -G3],[0, 0, -G3, 0]])\nmerge_nodes = [(3,0),]\nto_remove = [a for a,b in merge_nodes]\nids = [i for i in range(A.shape[0]) if i not in to_remove]\nz = np.array([0, 0, 0, 0, 1, 0])\n# print(G)\n# for na, nb in merge_nodes:\n#     G[nb,:] += G[na,:]",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "A = np.zeros((6,6))\nG = np.array([[0, 0, -G2, 0],[0, 0, -G1, 0],[-G2, -G1, 0, -G3],[0, 0, -G3, 0]])\nmerge_nodes = [(3,0),]\nto_remove = [a for a,b in merge_nodes]\nids = [i for i in range(A.shape[0]) if i not in to_remove]\nz = np.array([0, 0, 0, 0, 1, 0])\n# print(G)\n# for na, nb in merge_nodes:\n#     G[nb,:] += G[na,:]\n#     G[:,nb] += G[:,na]",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "G",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "G = np.array([[0, 0, -G2, 0],[0, 0, -G1, 0],[-G2, -G1, 0, -G3],[0, 0, -G3, 0]])\nmerge_nodes = [(3,0),]\nto_remove = [a for a,b in merge_nodes]\nids = [i for i in range(A.shape[0]) if i not in to_remove]\nz = np.array([0, 0, 0, 0, 1, 0])\n# print(G)\n# for na, nb in merge_nodes:\n#     G[nb,:] += G[na,:]\n#     G[:,nb] += G[:,na]\n#     G[na,:] = 0",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "merge_nodes",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "merge_nodes = [(3,0),]\nto_remove = [a for a,b in merge_nodes]\nids = [i for i in range(A.shape[0]) if i not in to_remove]\nz = np.array([0, 0, 0, 0, 1, 0])\n# print(G)\n# for na, nb in merge_nodes:\n#     G[nb,:] += G[na,:]\n#     G[:,nb] += G[:,na]\n#     G[na,:] = 0\n#     G[:,na] = 0",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "to_remove",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "to_remove = [a for a,b in merge_nodes]\nids = [i for i in range(A.shape[0]) if i not in to_remove]\nz = np.array([0, 0, 0, 0, 1, 0])\n# print(G)\n# for na, nb in merge_nodes:\n#     G[nb,:] += G[na,:]\n#     G[:,nb] += G[:,na]\n#     G[na,:] = 0\n#     G[:,na] = 0\n# print(G)",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "ids",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "ids = [i for i in range(A.shape[0]) if i not in to_remove]\nz = np.array([0, 0, 0, 0, 1, 0])\n# print(G)\n# for na, nb in merge_nodes:\n#     G[nb,:] += G[na,:]\n#     G[:,nb] += G[:,na]\n#     G[na,:] = 0\n#     G[:,na] = 0\n# print(G)\nfor i in range(4):",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "z = np.array([0, 0, 0, 0, 1, 0])\n# print(G)\n# for na, nb in merge_nodes:\n#     G[nb,:] += G[na,:]\n#     G[:,nb] += G[:,na]\n#     G[na,:] = 0\n#     G[:,na] = 0\n# print(G)\nfor i in range(4):\n    G[i,i] = -np.sum(G[i,:])",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "A[:4,:4]",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "A[:4,:4] = G\nA[3,5] = 1\nA[5,3] = 1\nA[1,4] = 1\nA[4,1] = 1\nprint(A)\nA = A[np.ix_(ids,ids)]\nz = z[ids]\nprint(A[1:,1:], z[1:])\nx = np.linalg.lstsq(A[1:,1:],z[1:])[0]",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "A[3,5]",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "A[3,5] = 1\nA[5,3] = 1\nA[1,4] = 1\nA[4,1] = 1\nprint(A)\nA = A[np.ix_(ids,ids)]\nz = z[ids]\nprint(A[1:,1:], z[1:])\nx = np.linalg.lstsq(A[1:,1:],z[1:])[0]\nprint(x)",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "A[5,3]",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "A[5,3] = 1\nA[1,4] = 1\nA[4,1] = 1\nprint(A)\nA = A[np.ix_(ids,ids)]\nz = z[ids]\nprint(A[1:,1:], z[1:])\nx = np.linalg.lstsq(A[1:,1:],z[1:])[0]\nprint(x)\nI = 1/(50 + 1/((1/50)+(1/200)))",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "A[1,4]",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "A[1,4] = 1\nA[4,1] = 1\nprint(A)\nA = A[np.ix_(ids,ids)]\nz = z[ids]\nprint(A[1:,1:], z[1:])\nx = np.linalg.lstsq(A[1:,1:],z[1:])[0]\nprint(x)\nI = 1/(50 + 1/((1/50)+(1/200)))\nprint(I)",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "A[4,1]",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "A[4,1] = 1\nprint(A)\nA = A[np.ix_(ids,ids)]\nz = z[ids]\nprint(A[1:,1:], z[1:])\nx = np.linalg.lstsq(A[1:,1:],z[1:])[0]\nprint(x)\nI = 1/(50 + 1/((1/50)+(1/200)))\nprint(I)",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "A = A[np.ix_(ids,ids)]\nz = z[ids]\nprint(A[1:,1:], z[1:])\nx = np.linalg.lstsq(A[1:,1:],z[1:])[0]\nprint(x)\nI = 1/(50 + 1/((1/50)+(1/200)))\nprint(I)",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "z = z[ids]\nprint(A[1:,1:], z[1:])\nx = np.linalg.lstsq(A[1:,1:],z[1:])[0]\nprint(x)\nI = 1/(50 + 1/((1/50)+(1/200)))\nprint(I)",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "x = np.linalg.lstsq(A[1:,1:],z[1:])[0]\nprint(x)\nI = 1/(50 + 1/((1/50)+(1/200)))\nprint(I)",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "I",
        "kind": 5,
        "importPath": "dev_scripts.MNA_test",
        "description": "dev_scripts.MNA_test",
        "peekOfCode": "I = 1/(50 + 1/((1/50)+(1/200)))\nprint(I)",
        "detail": "dev_scripts.MNA_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "dev_scripts.dc_test_1",
        "description": "dev_scripts.dc_test_1",
        "peekOfCode": "M = hv.Model()\nn1 = M.new_port(50)\nn2 = M.new_port(50)\n# simple LC filter at 2GHz\nL = M.inductor(n1, n2, 1e-9)\nC = M.capacitor(n2, M.gnd, 1e-12)\nfs = np.logspace(8, 12, 1001)\nS = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], logx=True, labels = ['S11', 'S21'])",
        "detail": "dev_scripts.dc_test_1",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "dev_scripts.dc_test_1",
        "description": "dev_scripts.dc_test_1",
        "peekOfCode": "n1 = M.new_port(50)\nn2 = M.new_port(50)\n# simple LC filter at 2GHz\nL = M.inductor(n1, n2, 1e-9)\nC = M.capacitor(n2, M.gnd, 1e-12)\nfs = np.logspace(8, 12, 1001)\nS = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], logx=True, labels = ['S11', 'S21'])",
        "detail": "dev_scripts.dc_test_1",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "dev_scripts.dc_test_1",
        "description": "dev_scripts.dc_test_1",
        "peekOfCode": "n2 = M.new_port(50)\n# simple LC filter at 2GHz\nL = M.inductor(n1, n2, 1e-9)\nC = M.capacitor(n2, M.gnd, 1e-12)\nfs = np.logspace(8, 12, 1001)\nS = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], logx=True, labels = ['S11', 'S21'])",
        "detail": "dev_scripts.dc_test_1",
        "documentation": {}
    },
    {
        "label": "L",
        "kind": 5,
        "importPath": "dev_scripts.dc_test_1",
        "description": "dev_scripts.dc_test_1",
        "peekOfCode": "L = M.inductor(n1, n2, 1e-9)\nC = M.capacitor(n2, M.gnd, 1e-12)\nfs = np.logspace(8, 12, 1001)\nS = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], logx=True, labels = ['S11', 'S21'])",
        "detail": "dev_scripts.dc_test_1",
        "documentation": {}
    },
    {
        "label": "C",
        "kind": 5,
        "importPath": "dev_scripts.dc_test_1",
        "description": "dev_scripts.dc_test_1",
        "peekOfCode": "C = M.capacitor(n2, M.gnd, 1e-12)\nfs = np.logspace(8, 12, 1001)\nS = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], logx=True, labels = ['S11', 'S21'])",
        "detail": "dev_scripts.dc_test_1",
        "documentation": {}
    },
    {
        "label": "fs",
        "kind": 5,
        "importPath": "dev_scripts.dc_test_1",
        "description": "dev_scripts.dc_test_1",
        "peekOfCode": "fs = np.logspace(8, 12, 1001)\nS = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], logx=True, labels = ['S11', 'S21'])",
        "detail": "dev_scripts.dc_test_1",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "dev_scripts.dc_test_1",
        "description": "dev_scripts.dc_test_1",
        "peekOfCode": "S = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], logx=True, labels = ['S11', 'S21'])",
        "detail": "dev_scripts.dc_test_1",
        "documentation": {}
    },
    {
        "label": "solve_eq",
        "kind": 2,
        "importPath": "dev_scripts.diode_test",
        "description": "dev_scripts.diode_test",
        "peekOfCode": "def solve_eq(f1: Callable, f2: Callable):\n    def eq(x):\n        return f1(x) - f2(x)\n    return fsolve(eq, 0.5)\nprint(f'Output Voltage: {solve_eq(vdiode, vleft)}')\n### Find numerically\nM = hv.Model()\nn1 = M.node()\nn2 = M.node()\ndc1 = M.DC_source(n1, 1.0)",
        "detail": "dev_scripts.diode_test",
        "documentation": {}
    },
    {
        "label": "vdiode",
        "kind": 5,
        "importPath": "dev_scripts.diode_test",
        "description": "dev_scripts.diode_test",
        "peekOfCode": "vdiode = lambda v: 1 - 200 * 1.216e-12*(np.exp(v/0.0258)-1)\nvleft = lambda v: v\ndef solve_eq(f1: Callable, f2: Callable):\n    def eq(x):\n        return f1(x) - f2(x)\n    return fsolve(eq, 0.5)\nprint(f'Output Voltage: {solve_eq(vdiode, vleft)}')\n### Find numerically\nM = hv.Model()\nn1 = M.node()",
        "detail": "dev_scripts.diode_test",
        "documentation": {}
    },
    {
        "label": "vleft",
        "kind": 5,
        "importPath": "dev_scripts.diode_test",
        "description": "dev_scripts.diode_test",
        "peekOfCode": "vleft = lambda v: v\ndef solve_eq(f1: Callable, f2: Callable):\n    def eq(x):\n        return f1(x) - f2(x)\n    return fsolve(eq, 0.5)\nprint(f'Output Voltage: {solve_eq(vdiode, vleft)}')\n### Find numerically\nM = hv.Model()\nn1 = M.node()\nn2 = M.node()",
        "detail": "dev_scripts.diode_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "dev_scripts.diode_test",
        "description": "dev_scripts.diode_test",
        "peekOfCode": "M = hv.Model()\nn1 = M.node()\nn2 = M.node()\ndc1 = M.DC_source(n1, 1.0)\nR = M.resistor(n1, n2, 200)\nD = nl.Diode(Rs = 0.001, I0=1.216e-12, N=1)\nD.connect(n2, M.gnd)\nV = M.run_dc(initial_voltage=0.3, maxiter=20)[-1]\nprint(V)\nprint(f'Output Voltage: {solve_eq(vdiode, vleft)}')",
        "detail": "dev_scripts.diode_test",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "dev_scripts.diode_test",
        "description": "dev_scripts.diode_test",
        "peekOfCode": "n1 = M.node()\nn2 = M.node()\ndc1 = M.DC_source(n1, 1.0)\nR = M.resistor(n1, n2, 200)\nD = nl.Diode(Rs = 0.001, I0=1.216e-12, N=1)\nD.connect(n2, M.gnd)\nV = M.run_dc(initial_voltage=0.3, maxiter=20)[-1]\nprint(V)\nprint(f'Output Voltage: {solve_eq(vdiode, vleft)}')",
        "detail": "dev_scripts.diode_test",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "dev_scripts.diode_test",
        "description": "dev_scripts.diode_test",
        "peekOfCode": "n2 = M.node()\ndc1 = M.DC_source(n1, 1.0)\nR = M.resistor(n1, n2, 200)\nD = nl.Diode(Rs = 0.001, I0=1.216e-12, N=1)\nD.connect(n2, M.gnd)\nV = M.run_dc(initial_voltage=0.3, maxiter=20)[-1]\nprint(V)\nprint(f'Output Voltage: {solve_eq(vdiode, vleft)}')",
        "detail": "dev_scripts.diode_test",
        "documentation": {}
    },
    {
        "label": "dc1",
        "kind": 5,
        "importPath": "dev_scripts.diode_test",
        "description": "dev_scripts.diode_test",
        "peekOfCode": "dc1 = M.DC_source(n1, 1.0)\nR = M.resistor(n1, n2, 200)\nD = nl.Diode(Rs = 0.001, I0=1.216e-12, N=1)\nD.connect(n2, M.gnd)\nV = M.run_dc(initial_voltage=0.3, maxiter=20)[-1]\nprint(V)\nprint(f'Output Voltage: {solve_eq(vdiode, vleft)}')",
        "detail": "dev_scripts.diode_test",
        "documentation": {}
    },
    {
        "label": "R",
        "kind": 5,
        "importPath": "dev_scripts.diode_test",
        "description": "dev_scripts.diode_test",
        "peekOfCode": "R = M.resistor(n1, n2, 200)\nD = nl.Diode(Rs = 0.001, I0=1.216e-12, N=1)\nD.connect(n2, M.gnd)\nV = M.run_dc(initial_voltage=0.3, maxiter=20)[-1]\nprint(V)\nprint(f'Output Voltage: {solve_eq(vdiode, vleft)}')",
        "detail": "dev_scripts.diode_test",
        "documentation": {}
    },
    {
        "label": "D",
        "kind": 5,
        "importPath": "dev_scripts.diode_test",
        "description": "dev_scripts.diode_test",
        "peekOfCode": "D = nl.Diode(Rs = 0.001, I0=1.216e-12, N=1)\nD.connect(n2, M.gnd)\nV = M.run_dc(initial_voltage=0.3, maxiter=20)[-1]\nprint(V)\nprint(f'Output Voltage: {solve_eq(vdiode, vleft)}')",
        "detail": "dev_scripts.diode_test",
        "documentation": {}
    },
    {
        "label": "V",
        "kind": 5,
        "importPath": "dev_scripts.diode_test",
        "description": "dev_scripts.diode_test",
        "peekOfCode": "V = M.run_dc(initial_voltage=0.3, maxiter=20)[-1]\nprint(V)\nprint(f'Output Voltage: {solve_eq(vdiode, vleft)}')",
        "detail": "dev_scripts.diode_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "dev_scripts.lumped_component_test",
        "description": "dev_scripts.lumped_component_test",
        "peekOfCode": "M = hv.Model()\np1 = M.new_port(50)\np2 = M.new_port(50)\nfc = 1e9\nCap = 5e-12\n# compute L from the cutoff frequency of LC filter\nL = 1 / (4 * (hv.PI**2) * Cap * (fc**2))\nCL = smd.SMDInductor(L, smd.SMDInductorSize.L0402)\nCC = smd.SMDCapacitor(Cap, package=smd.SMDCapacitorSize.C0402)\np1 > CL > p2 > CC > M.gnd",
        "detail": "dev_scripts.lumped_component_test",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "dev_scripts.lumped_component_test",
        "description": "dev_scripts.lumped_component_test",
        "peekOfCode": "p1 = M.new_port(50)\np2 = M.new_port(50)\nfc = 1e9\nCap = 5e-12\n# compute L from the cutoff frequency of LC filter\nL = 1 / (4 * (hv.PI**2) * Cap * (fc**2))\nCL = smd.SMDInductor(L, smd.SMDInductorSize.L0402)\nCC = smd.SMDCapacitor(Cap, package=smd.SMDCapacitorSize.C0402)\np1 > CL > p2 > CC > M.gnd\nprint(CL.function(1e3))",
        "detail": "dev_scripts.lumped_component_test",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "dev_scripts.lumped_component_test",
        "description": "dev_scripts.lumped_component_test",
        "peekOfCode": "p2 = M.new_port(50)\nfc = 1e9\nCap = 5e-12\n# compute L from the cutoff frequency of LC filter\nL = 1 / (4 * (hv.PI**2) * Cap * (fc**2))\nCL = smd.SMDInductor(L, smd.SMDInductorSize.L0402)\nCC = smd.SMDCapacitor(Cap, package=smd.SMDCapacitorSize.C0402)\np1 > CL > p2 > CC > M.gnd\nprint(CL.function(1e3))\nprint(CC.function(1e3))",
        "detail": "dev_scripts.lumped_component_test",
        "documentation": {}
    },
    {
        "label": "fc",
        "kind": 5,
        "importPath": "dev_scripts.lumped_component_test",
        "description": "dev_scripts.lumped_component_test",
        "peekOfCode": "fc = 1e9\nCap = 5e-12\n# compute L from the cutoff frequency of LC filter\nL = 1 / (4 * (hv.PI**2) * Cap * (fc**2))\nCL = smd.SMDInductor(L, smd.SMDInductorSize.L0402)\nCC = smd.SMDCapacitor(Cap, package=smd.SMDCapacitorSize.C0402)\np1 > CL > p2 > CC > M.gnd\nprint(CL.function(1e3))\nprint(CC.function(1e3))\n#M.inductor(p1, p2, L)",
        "detail": "dev_scripts.lumped_component_test",
        "documentation": {}
    },
    {
        "label": "Cap",
        "kind": 5,
        "importPath": "dev_scripts.lumped_component_test",
        "description": "dev_scripts.lumped_component_test",
        "peekOfCode": "Cap = 5e-12\n# compute L from the cutoff frequency of LC filter\nL = 1 / (4 * (hv.PI**2) * Cap * (fc**2))\nCL = smd.SMDInductor(L, smd.SMDInductorSize.L0402)\nCC = smd.SMDCapacitor(Cap, package=smd.SMDCapacitorSize.C0402)\np1 > CL > p2 > CC > M.gnd\nprint(CL.function(1e3))\nprint(CC.function(1e3))\n#M.inductor(p1, p2, L)\n#M.capacitor(M.gnd, p2, Cap)",
        "detail": "dev_scripts.lumped_component_test",
        "documentation": {}
    },
    {
        "label": "L",
        "kind": 5,
        "importPath": "dev_scripts.lumped_component_test",
        "description": "dev_scripts.lumped_component_test",
        "peekOfCode": "L = 1 / (4 * (hv.PI**2) * Cap * (fc**2))\nCL = smd.SMDInductor(L, smd.SMDInductorSize.L0402)\nCC = smd.SMDCapacitor(Cap, package=smd.SMDCapacitorSize.C0402)\np1 > CL > p2 > CC > M.gnd\nprint(CL.function(1e3))\nprint(CC.function(1e3))\n#M.inductor(p1, p2, L)\n#M.capacitor(M.gnd, p2, Cap)\nfs = hv.frange(0.01e9,10e9,10001)\nS = M.run(fs)",
        "detail": "dev_scripts.lumped_component_test",
        "documentation": {}
    },
    {
        "label": "CL",
        "kind": 5,
        "importPath": "dev_scripts.lumped_component_test",
        "description": "dev_scripts.lumped_component_test",
        "peekOfCode": "CL = smd.SMDInductor(L, smd.SMDInductorSize.L0402)\nCC = smd.SMDCapacitor(Cap, package=smd.SMDCapacitorSize.C0402)\np1 > CL > p2 > CC > M.gnd\nprint(CL.function(1e3))\nprint(CC.function(1e3))\n#M.inductor(p1, p2, L)\n#M.capacitor(M.gnd, p2, Cap)\nfs = hv.frange(0.01e9,10e9,10001)\nS = M.run(fs)\nM.print_components()",
        "detail": "dev_scripts.lumped_component_test",
        "documentation": {}
    },
    {
        "label": "CC",
        "kind": 5,
        "importPath": "dev_scripts.lumped_component_test",
        "description": "dev_scripts.lumped_component_test",
        "peekOfCode": "CC = smd.SMDCapacitor(Cap, package=smd.SMDCapacitorSize.C0402)\np1 > CL > p2 > CC > M.gnd\nprint(CL.function(1e3))\nprint(CC.function(1e3))\n#M.inductor(p1, p2, L)\n#M.capacitor(M.gnd, p2, Cap)\nfs = hv.frange(0.01e9,10e9,10001)\nS = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S21], logx=True)",
        "detail": "dev_scripts.lumped_component_test",
        "documentation": {}
    },
    {
        "label": "fs",
        "kind": 5,
        "importPath": "dev_scripts.lumped_component_test",
        "description": "dev_scripts.lumped_component_test",
        "peekOfCode": "fs = hv.frange(0.01e9,10e9,10001)\nS = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S21], logx=True)",
        "detail": "dev_scripts.lumped_component_test",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "dev_scripts.lumped_component_test",
        "description": "dev_scripts.lumped_component_test",
        "peekOfCode": "S = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S21], logx=True)",
        "detail": "dev_scripts.lumped_component_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "dev_scripts.optimize_test",
        "description": "dev_scripts.optimize_test",
        "peekOfCode": "M = hv.QuickModel(suppress_loadbar=True)\nO = opt.Optimiser(M)\np1 = M.new_port(50)\np2 = M.new_port(50)\nn1 = M.node()\nn2 = M.node()\nM.LC(p1, n1, O.ind(), O.cap())\nM.LC(n1, n2, O.ind(), O.cap())\nM.LC(n2, p2, O.ind(), O.cap())\nM.C(M.gnd, p1, O.cap())",
        "detail": "dev_scripts.optimize_test",
        "documentation": {}
    },
    {
        "label": "O",
        "kind": 5,
        "importPath": "dev_scripts.optimize_test",
        "description": "dev_scripts.optimize_test",
        "peekOfCode": "O = opt.Optimiser(M)\np1 = M.new_port(50)\np2 = M.new_port(50)\nn1 = M.node()\nn2 = M.node()\nM.LC(p1, n1, O.ind(), O.cap())\nM.LC(n1, n2, O.ind(), O.cap())\nM.LC(n2, p2, O.ind(), O.cap())\nM.C(M.gnd, p1, O.cap())\nM.C(M.gnd, p2, O.cap())",
        "detail": "dev_scripts.optimize_test",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "dev_scripts.optimize_test",
        "description": "dev_scripts.optimize_test",
        "peekOfCode": "p1 = M.new_port(50)\np2 = M.new_port(50)\nn1 = M.node()\nn2 = M.node()\nM.LC(p1, n1, O.ind(), O.cap())\nM.LC(n1, n2, O.ind(), O.cap())\nM.LC(n2, p2, O.ind(), O.cap())\nM.C(M.gnd, p1, O.cap())\nM.C(M.gnd, p2, O.cap())\nM.C(M.gnd, n1, O.cap())",
        "detail": "dev_scripts.optimize_test",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "dev_scripts.optimize_test",
        "description": "dev_scripts.optimize_test",
        "peekOfCode": "p2 = M.new_port(50)\nn1 = M.node()\nn2 = M.node()\nM.LC(p1, n1, O.ind(), O.cap())\nM.LC(n1, n2, O.ind(), O.cap())\nM.LC(n2, p2, O.ind(), O.cap())\nM.C(M.gnd, p1, O.cap())\nM.C(M.gnd, p2, O.cap())\nM.C(M.gnd, n1, O.cap())\nM.C(M.gnd, n2, O.cap())",
        "detail": "dev_scripts.optimize_test",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "dev_scripts.optimize_test",
        "description": "dev_scripts.optimize_test",
        "peekOfCode": "n1 = M.node()\nn2 = M.node()\nM.LC(p1, n1, O.ind(), O.cap())\nM.LC(n1, n2, O.ind(), O.cap())\nM.LC(n2, p2, O.ind(), O.cap())\nM.C(M.gnd, p1, O.cap())\nM.C(M.gnd, p2, O.cap())\nM.C(M.gnd, n1, O.cap())\nM.C(M.gnd, n2, O.cap())\nO.add_freqlevel(2e9, 3e9, 21, (1,1), upper_limit=-15)",
        "detail": "dev_scripts.optimize_test",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "dev_scripts.optimize_test",
        "description": "dev_scripts.optimize_test",
        "peekOfCode": "n2 = M.node()\nM.LC(p1, n1, O.ind(), O.cap())\nM.LC(n1, n2, O.ind(), O.cap())\nM.LC(n2, p2, O.ind(), O.cap())\nM.C(M.gnd, p1, O.cap())\nM.C(M.gnd, p2, O.cap())\nM.C(M.gnd, n1, O.cap())\nM.C(M.gnd, n2, O.cap())\nO.add_freqlevel(2e9, 3e9, 21, (1,1), upper_limit=-15)\nO.add_freqlevel(3.3e9, 4e9, 21, (2,1), upper_limit=-30)",
        "detail": "dev_scripts.optimize_test",
        "documentation": {}
    },
    {
        "label": "x0",
        "kind": 5,
        "importPath": "dev_scripts.optimize_test",
        "description": "dev_scripts.optimize_test",
        "peekOfCode": "x0 = differential_evolution(O.generate_objective(2, differential_weighting=True), O.bounds, popsize=10)\nfs = hv.frange(1e9, 8e9, 1001)\nS = M.run(fs)\nM.print_components()\nM.suppress_loadbar = False\nS2 = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], spec_area=O.spec_area)\nhv.plot_s_parameters(fs, [S2.S11, S2.S21], spec_area=O.spec_area)",
        "detail": "dev_scripts.optimize_test",
        "documentation": {}
    },
    {
        "label": "fs",
        "kind": 5,
        "importPath": "dev_scripts.optimize_test",
        "description": "dev_scripts.optimize_test",
        "peekOfCode": "fs = hv.frange(1e9, 8e9, 1001)\nS = M.run(fs)\nM.print_components()\nM.suppress_loadbar = False\nS2 = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], spec_area=O.spec_area)\nhv.plot_s_parameters(fs, [S2.S11, S2.S21], spec_area=O.spec_area)",
        "detail": "dev_scripts.optimize_test",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "dev_scripts.optimize_test",
        "description": "dev_scripts.optimize_test",
        "peekOfCode": "S = M.run(fs)\nM.print_components()\nM.suppress_loadbar = False\nS2 = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], spec_area=O.spec_area)\nhv.plot_s_parameters(fs, [S2.S11, S2.S21], spec_area=O.spec_area)",
        "detail": "dev_scripts.optimize_test",
        "documentation": {}
    },
    {
        "label": "M.suppress_loadbar",
        "kind": 5,
        "importPath": "dev_scripts.optimize_test",
        "description": "dev_scripts.optimize_test",
        "peekOfCode": "M.suppress_loadbar = False\nS2 = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], spec_area=O.spec_area)\nhv.plot_s_parameters(fs, [S2.S11, S2.S21], spec_area=O.spec_area)",
        "detail": "dev_scripts.optimize_test",
        "documentation": {}
    },
    {
        "label": "S2",
        "kind": 5,
        "importPath": "dev_scripts.optimize_test",
        "description": "dev_scripts.optimize_test",
        "peekOfCode": "S2 = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], spec_area=O.spec_area)\nhv.plot_s_parameters(fs, [S2.S11, S2.S21], spec_area=O.spec_area)",
        "detail": "dev_scripts.optimize_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "dev_scripts.param_sweep_test",
        "description": "dev_scripts.param_sweep_test",
        "peekOfCode": "M = hv.QuickModel()\np1 = M.new_port(50)\np2 = M.new_port(200)\nps = hv.ParameterSweep()\nLs1, Cs1 = ps.lin(1e-9,10e-9).lin(1e-12,10e-12).add(7)\nCs = ps.lin(1e-12,10e-12).add(5)[0]\nM.L(p1, p2, Ls1)\nM.C(p1, p2, Cs1)\nM.C(M.gnd, p2, Cs)\nfs = hv.frange(0.01e9,4e9,101)",
        "detail": "dev_scripts.param_sweep_test",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "dev_scripts.param_sweep_test",
        "description": "dev_scripts.param_sweep_test",
        "peekOfCode": "p1 = M.new_port(50)\np2 = M.new_port(200)\nps = hv.ParameterSweep()\nLs1, Cs1 = ps.lin(1e-9,10e-9).lin(1e-12,10e-12).add(7)\nCs = ps.lin(1e-12,10e-12).add(5)[0]\nM.L(p1, p2, Ls1)\nM.C(p1, p2, Cs1)\nM.C(M.gnd, p2, Cs)\nfs = hv.frange(0.01e9,4e9,101)\nfor i in ps.iterate():",
        "detail": "dev_scripts.param_sweep_test",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "dev_scripts.param_sweep_test",
        "description": "dev_scripts.param_sweep_test",
        "peekOfCode": "p2 = M.new_port(200)\nps = hv.ParameterSweep()\nLs1, Cs1 = ps.lin(1e-9,10e-9).lin(1e-12,10e-12).add(7)\nCs = ps.lin(1e-12,10e-12).add(5)[0]\nM.L(p1, p2, Ls1)\nM.C(p1, p2, Cs1)\nM.C(M.gnd, p2, Cs)\nfs = hv.frange(0.01e9,4e9,101)\nfor i in ps.iterate():\n    S = M.run(fs)",
        "detail": "dev_scripts.param_sweep_test",
        "documentation": {}
    },
    {
        "label": "ps",
        "kind": 5,
        "importPath": "dev_scripts.param_sweep_test",
        "description": "dev_scripts.param_sweep_test",
        "peekOfCode": "ps = hv.ParameterSweep()\nLs1, Cs1 = ps.lin(1e-9,10e-9).lin(1e-12,10e-12).add(7)\nCs = ps.lin(1e-12,10e-12).add(5)[0]\nM.L(p1, p2, Ls1)\nM.C(p1, p2, Cs1)\nM.C(M.gnd, p2, Cs)\nfs = hv.frange(0.01e9,4e9,101)\nfor i in ps.iterate():\n    S = M.run(fs)\n    ps.submit(S,fs)",
        "detail": "dev_scripts.param_sweep_test",
        "documentation": {}
    },
    {
        "label": "Cs",
        "kind": 5,
        "importPath": "dev_scripts.param_sweep_test",
        "description": "dev_scripts.param_sweep_test",
        "peekOfCode": "Cs = ps.lin(1e-12,10e-12).add(5)[0]\nM.L(p1, p2, Ls1)\nM.C(p1, p2, Cs1)\nM.C(M.gnd, p2, Cs)\nfs = hv.frange(0.01e9,4e9,101)\nfor i in ps.iterate():\n    S = M.run(fs)\n    ps.submit(S,fs)\nmdims = ps.generate_mdim()\nprint(mdims._axes)",
        "detail": "dev_scripts.param_sweep_test",
        "documentation": {}
    },
    {
        "label": "fs",
        "kind": 5,
        "importPath": "dev_scripts.param_sweep_test",
        "description": "dev_scripts.param_sweep_test",
        "peekOfCode": "fs = hv.frange(0.01e9,4e9,101)\nfor i in ps.iterate():\n    S = M.run(fs)\n    ps.submit(S,fs)\nmdims = ps.generate_mdim()\nprint(mdims._axes)\nprint(mdims._extra_dims)\n#print(mdims._sdata)\nprint(mdims._shape)\nprint(mdims(2,1).shape)",
        "detail": "dev_scripts.param_sweep_test",
        "documentation": {}
    },
    {
        "label": "mdims",
        "kind": 5,
        "importPath": "dev_scripts.param_sweep_test",
        "description": "dev_scripts.param_sweep_test",
        "peekOfCode": "mdims = ps.generate_mdim()\nprint(mdims._axes)\nprint(mdims._extra_dims)\n#print(mdims._sdata)\nprint(mdims._shape)\nprint(mdims(2,1).shape)\nLs = np.linspace(1e-9,10e-9,51)\nndS = mdims.intS(2,1)\nhv.plot(Ls, np.abs(ndS(Ls, 5e-12, 3e9)))\n#hv.plot_s_parameters(fs,[np.squeeze(mdims[i,11,1,0,:]) for i in range(21)])",
        "detail": "dev_scripts.param_sweep_test",
        "documentation": {}
    },
    {
        "label": "Ls",
        "kind": 5,
        "importPath": "dev_scripts.param_sweep_test",
        "description": "dev_scripts.param_sweep_test",
        "peekOfCode": "Ls = np.linspace(1e-9,10e-9,51)\nndS = mdims.intS(2,1)\nhv.plot(Ls, np.abs(ndS(Ls, 5e-12, 3e9)))\n#hv.plot_s_parameters(fs,[np.squeeze(mdims[i,11,1,0,:]) for i in range(21)])",
        "detail": "dev_scripts.param_sweep_test",
        "documentation": {}
    },
    {
        "label": "ndS",
        "kind": 5,
        "importPath": "dev_scripts.param_sweep_test",
        "description": "dev_scripts.param_sweep_test",
        "peekOfCode": "ndS = mdims.intS(2,1)\nhv.plot(Ls, np.abs(ndS(Ls, 5e-12, 3e9)))\n#hv.plot_s_parameters(fs,[np.squeeze(mdims[i,11,1,0,:]) for i in range(21)])",
        "detail": "dev_scripts.param_sweep_test",
        "documentation": {}
    },
    {
        "label": "gen_grid",
        "kind": 2,
        "importPath": "dev_scripts.smithplot_test",
        "description": "dev_scripts.smithplot_test",
        "peekOfCode": "def gen_grid(xs: tuple, ys: tuple) -> list[np.ndarray]:\n    xgrid = np.arange(xs[0], xs[1]+xs[2], xs[2])\n    ygrid = np.arange(ys[0], ys[1]+ys[2], ys[2])\n    xsmooth = np.logspace(np.log10(xs[0]+1e-8), np.log10(xs[1]), 201)\n    ysmooth = np.logspace(np.log10(ys[0]+1e-8), np.log10(ys[1]), 201)\n    ones = np.ones((101,))\n    lines = []\n    for x in xgrid:\n        lines.append((x*ones, ysmooth))\n        lines.append((x*ones, -ysmooth))",
        "detail": "dev_scripts.smithplot_test",
        "documentation": {}
    },
    {
        "label": "generate_grids",
        "kind": 2,
        "importPath": "dev_scripts.smithplot_test",
        "description": "dev_scripts.smithplot_test",
        "peekOfCode": "def generate_grids(orders = (0, 0.5, 1, 2, 10, 50,1e5)) -> list[tuple[np.ndarray, np.ndarray]]:\n    lines = []\n    xgrids = orders\n    for o1, o2 in zip(xgrids[:-1], xgrids[1:]):\n        step = o2/10\n        lines += gen_grid((0, o2, step), (0, o2, step))   \n    return lines\ndef smith_transform(lines: list[tuple[np.ndarray, np.ndarray]]) -> list[tuple[np.ndarray, np.ndarray]]:\n    new_lines = []\n    for line in lines:",
        "detail": "dev_scripts.smithplot_test",
        "documentation": {}
    },
    {
        "label": "smith_transform",
        "kind": 2,
        "importPath": "dev_scripts.smithplot_test",
        "description": "dev_scripts.smithplot_test",
        "peekOfCode": "def smith_transform(lines: list[tuple[np.ndarray, np.ndarray]]) -> list[tuple[np.ndarray, np.ndarray]]:\n    new_lines = []\n    for line in lines:\n        x, y = line\n        z = x + 1j*y\n        new_z = (z-1)/(z+1)\n        new_x = new_z.real\n        new_y = new_z.imag\n        new_lines.append((new_x, new_y))\n    return new_lines",
        "detail": "dev_scripts.smithplot_test",
        "documentation": {}
    },
    {
        "label": "plot_grid",
        "kind": 2,
        "importPath": "dev_scripts.smithplot_test",
        "description": "dev_scripts.smithplot_test",
        "peekOfCode": "def plot_grid(lines):\n    fig, ax = plt.subplots()\n    for line in lines:\n        ax.plot(line[0], line[1], color='grey', alpha=0.5)\n    plt.show()\nplot_grid(smith_transform((generate_grids())))",
        "detail": "dev_scripts.smithplot_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "dev_scripts.spice_lib_import_test",
        "description": "dev_scripts.spice_lib_import_test",
        "peekOfCode": "M = hv.Model()\nn1 = M.new_port(50)\nn2 = M.new_port(50)\n#ni = M.node()\nL = clib.C0603_885382206001_220PF()\nL.connect(n1,n2)\nC = clib.L0402_7847803100_1N()\nC.connect(n2,M.gnd)\nfs = np.logspace(8, 12, 1001)\nS = M.run(fs)",
        "detail": "dev_scripts.spice_lib_import_test",
        "documentation": {}
    },
    {
        "label": "n1",
        "kind": 5,
        "importPath": "dev_scripts.spice_lib_import_test",
        "description": "dev_scripts.spice_lib_import_test",
        "peekOfCode": "n1 = M.new_port(50)\nn2 = M.new_port(50)\n#ni = M.node()\nL = clib.C0603_885382206001_220PF()\nL.connect(n1,n2)\nC = clib.L0402_7847803100_1N()\nC.connect(n2,M.gnd)\nfs = np.logspace(8, 12, 1001)\nS = M.run(fs)",
        "detail": "dev_scripts.spice_lib_import_test",
        "documentation": {}
    },
    {
        "label": "n2",
        "kind": 5,
        "importPath": "dev_scripts.spice_lib_import_test",
        "description": "dev_scripts.spice_lib_import_test",
        "peekOfCode": "n2 = M.new_port(50)\n#ni = M.node()\nL = clib.C0603_885382206001_220PF()\nL.connect(n1,n2)\nC = clib.L0402_7847803100_1N()\nC.connect(n2,M.gnd)\nfs = np.logspace(8, 12, 1001)\nS = M.run(fs)",
        "detail": "dev_scripts.spice_lib_import_test",
        "documentation": {}
    },
    {
        "label": "#ni",
        "kind": 5,
        "importPath": "dev_scripts.spice_lib_import_test",
        "description": "dev_scripts.spice_lib_import_test",
        "peekOfCode": "#ni = M.node()\nL = clib.C0603_885382206001_220PF()\nL.connect(n1,n2)\nC = clib.L0402_7847803100_1N()\nC.connect(n2,M.gnd)\nfs = np.logspace(8, 12, 1001)\nS = M.run(fs)",
        "detail": "dev_scripts.spice_lib_import_test",
        "documentation": {}
    },
    {
        "label": "L",
        "kind": 5,
        "importPath": "dev_scripts.spice_lib_import_test",
        "description": "dev_scripts.spice_lib_import_test",
        "peekOfCode": "L = clib.C0603_885382206001_220PF()\nL.connect(n1,n2)\nC = clib.L0402_7847803100_1N()\nC.connect(n2,M.gnd)\nfs = np.logspace(8, 12, 1001)\nS = M.run(fs)",
        "detail": "dev_scripts.spice_lib_import_test",
        "documentation": {}
    },
    {
        "label": "C",
        "kind": 5,
        "importPath": "dev_scripts.spice_lib_import_test",
        "description": "dev_scripts.spice_lib_import_test",
        "peekOfCode": "C = clib.L0402_7847803100_1N()\nC.connect(n2,M.gnd)\nfs = np.logspace(8, 12, 1001)\nS = M.run(fs)",
        "detail": "dev_scripts.spice_lib_import_test",
        "documentation": {}
    },
    {
        "label": "fs",
        "kind": 5,
        "importPath": "dev_scripts.spice_lib_import_test",
        "description": "dev_scripts.spice_lib_import_test",
        "peekOfCode": "fs = np.logspace(8, 12, 1001)\nS = M.run(fs)",
        "detail": "dev_scripts.spice_lib_import_test",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "dev_scripts.spice_lib_import_test",
        "description": "dev_scripts.spice_lib_import_test",
        "peekOfCode": "S = M.run(fs)",
        "detail": "dev_scripts.spice_lib_import_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "dev_scripts.standard_lib_test",
        "description": "dev_scripts.standard_lib_test",
        "peekOfCode": "M = hv.Model()\np1 = M.new_port(50)\np2 = M.new_port(50)\nM.filters.cauer_filter(M.gnd, p1, p2, 3e9, 0.5e9, 5, \n                       type=hv.BandType.BANDPASS, \n                       kind=hv.FilterType.BUTTERWORTH)\nM.DC_source(M(3), 1.0)\nM.resistor(M(3),p1, 500000)\nM.terminal(p1, 5000)\nfs = hv.frange(0.01e9, 8e9, 501)",
        "detail": "dev_scripts.standard_lib_test",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "dev_scripts.standard_lib_test",
        "description": "dev_scripts.standard_lib_test",
        "peekOfCode": "p1 = M.new_port(50)\np2 = M.new_port(50)\nM.filters.cauer_filter(M.gnd, p1, p2, 3e9, 0.5e9, 5, \n                       type=hv.BandType.BANDPASS, \n                       kind=hv.FilterType.BUTTERWORTH)\nM.DC_source(M(3), 1.0)\nM.resistor(M(3),p1, 500000)\nM.terminal(p1, 5000)\nfs = hv.frange(0.01e9, 8e9, 501)\n#fs = np.array([1,3e9])",
        "detail": "dev_scripts.standard_lib_test",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "dev_scripts.standard_lib_test",
        "description": "dev_scripts.standard_lib_test",
        "peekOfCode": "p2 = M.new_port(50)\nM.filters.cauer_filter(M.gnd, p1, p2, 3e9, 0.5e9, 5, \n                       type=hv.BandType.BANDPASS, \n                       kind=hv.FilterType.BUTTERWORTH)\nM.DC_source(M(3), 1.0)\nM.resistor(M(3),p1, 500000)\nM.terminal(p1, 5000)\nfs = hv.frange(0.01e9, 8e9, 501)\n#fs = np.array([1,3e9])\nS = M.run(fs)",
        "detail": "dev_scripts.standard_lib_test",
        "documentation": {}
    },
    {
        "label": "fs",
        "kind": 5,
        "importPath": "dev_scripts.standard_lib_test",
        "description": "dev_scripts.standard_lib_test",
        "peekOfCode": "fs = hv.frange(0.01e9, 8e9, 501)\n#fs = np.array([1,3e9])\nS = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], logx=True)\nhv.smith(fs, S.S11)\nM.print_components()",
        "detail": "dev_scripts.standard_lib_test",
        "documentation": {}
    },
    {
        "label": "#fs",
        "kind": 5,
        "importPath": "dev_scripts.standard_lib_test",
        "description": "dev_scripts.standard_lib_test",
        "peekOfCode": "#fs = np.array([1,3e9])\nS = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], logx=True)\nhv.smith(fs, S.S11)\nM.print_components()",
        "detail": "dev_scripts.standard_lib_test",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "dev_scripts.standard_lib_test",
        "description": "dev_scripts.standard_lib_test",
        "peekOfCode": "S = M.run(fs)\nhv.plot_s_parameters(fs, [S.S11, S.S21], logx=True)\nhv.smith(fs, S.S11)\nM.print_components()",
        "detail": "dev_scripts.standard_lib_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "M = hv.Model()\noptr = opt.Optimiser(M)\np1 = M.new_port(50)\np2 = M.new_port(50)\nLNA = FileBasedNPort('lna_touchstone.s2p', interp_type='cubic')\nLNA.connect(M(2),p2)\n#M.capacitor(M(1), M.gnd, optr.cap())\n#M.inductor(p1, M(1), optr.ind())\nM.inductor(p1, M(1), optr.ind(True, -9, (-14,-5)))\nM.capacitor(M(1), M.gnd, optr.cap())",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "optr",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "optr = opt.Optimiser(M)\np1 = M.new_port(50)\np2 = M.new_port(50)\nLNA = FileBasedNPort('lna_touchstone.s2p', interp_type='cubic')\nLNA.connect(M(2),p2)\n#M.capacitor(M(1), M.gnd, optr.cap())\n#M.inductor(p1, M(1), optr.ind())\nM.inductor(p1, M(1), optr.ind(True, -9, (-14,-5)))\nM.capacitor(M(1), M.gnd, optr.cap())\nM.transmissionline(M.gnd, M(1), M(2), optr.add_param(50,(10,200), unit='Ohm'), 1, optr.add_param(0.001, (0.0001, 0.05), unit='m'))",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "p1 = M.new_port(50)\np2 = M.new_port(50)\nLNA = FileBasedNPort('lna_touchstone.s2p', interp_type='cubic')\nLNA.connect(M(2),p2)\n#M.capacitor(M(1), M.gnd, optr.cap())\n#M.inductor(p1, M(1), optr.ind())\nM.inductor(p1, M(1), optr.ind(True, -9, (-14,-5)))\nM.capacitor(M(1), M.gnd, optr.cap())\nM.transmissionline(M.gnd, M(1), M(2), optr.add_param(50,(10,200), unit='Ohm'), 1, optr.add_param(0.001, (0.0001, 0.05), unit='m'))\noptr.add_freqlevel(5e9, 6e9, 51, (1,1), upper_limit= -50)",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "p2 = M.new_port(50)\nLNA = FileBasedNPort('lna_touchstone.s2p', interp_type='cubic')\nLNA.connect(M(2),p2)\n#M.capacitor(M(1), M.gnd, optr.cap())\n#M.inductor(p1, M(1), optr.ind())\nM.inductor(p1, M(1), optr.ind(True, -9, (-14,-5)))\nM.capacitor(M(1), M.gnd, optr.cap())\nM.transmissionline(M.gnd, M(1), M(2), optr.add_param(50,(10,200), unit='Ohm'), 1, optr.add_param(0.001, (0.0001, 0.05), unit='m'))\noptr.add_freqlevel(5e9, 6e9, 51, (1,1), upper_limit= -50)\nfunc = optr.generate_objective()",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "LNA",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "LNA = FileBasedNPort('lna_touchstone.s2p', interp_type='cubic')\nLNA.connect(M(2),p2)\n#M.capacitor(M(1), M.gnd, optr.cap())\n#M.inductor(p1, M(1), optr.ind())\nM.inductor(p1, M(1), optr.ind(True, -9, (-14,-5)))\nM.capacitor(M(1), M.gnd, optr.cap())\nM.transmissionline(M.gnd, M(1), M(2), optr.add_param(50,(10,200), unit='Ohm'), 1, optr.add_param(0.001, (0.0001, 0.05), unit='m'))\noptr.add_freqlevel(5e9, 6e9, 51, (1,1), upper_limit= -50)\nfunc = optr.generate_objective()\ndifferential_evolution(func, bounds=optr.bounds)",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "func",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "func = optr.generate_objective()\ndifferential_evolution(func, bounds=optr.bounds)\n#brute(func, ranges=optr.bounds)\nfs = hv.frange(1e9,10e9,1001)\nS = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S21])\nhv.smith(fs, S.S11)\nM = hv.Model()\np1 = M.new_port(50)",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "fs",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "fs = hv.frange(1e9,10e9,1001)\nS = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S21])\nhv.smith(fs, S.S11)\nM = hv.Model()\np1 = M.new_port(50)\np2 = M.new_port(50)\np3 = M.new_port(50)\nSWTCH = FileBasedNPort('switch_file.s3p', interp_type='cubic')",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "S = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S21])\nhv.smith(fs, S.S11)\nM = hv.Model()\np1 = M.new_port(50)\np2 = M.new_port(50)\np3 = M.new_port(50)\nSWTCH = FileBasedNPort('switch_file.s3p', interp_type='cubic')\nSWTCH.connect(p1,p2,p3)",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "M = hv.Model()\np1 = M.new_port(50)\np2 = M.new_port(50)\np3 = M.new_port(50)\nSWTCH = FileBasedNPort('switch_file.s3p', interp_type='cubic')\nSWTCH.connect(p1,p2,p3)\nfs = hv.frange(0.001e9,0.1e9,1001)\nS = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S12,S.S13,S.S21,S.S22,S.S23,S.S31,S.S32,S.S33], labels=[f'S{i+1}{j+1}' for i in range(3) for j in range(3)])",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "p1",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "p1 = M.new_port(50)\np2 = M.new_port(50)\np3 = M.new_port(50)\nSWTCH = FileBasedNPort('switch_file.s3p', interp_type='cubic')\nSWTCH.connect(p1,p2,p3)\nfs = hv.frange(0.001e9,0.1e9,1001)\nS = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S12,S.S13,S.S21,S.S22,S.S23,S.S31,S.S32,S.S33], labels=[f'S{i+1}{j+1}' for i in range(3) for j in range(3)])",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "p2",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "p2 = M.new_port(50)\np3 = M.new_port(50)\nSWTCH = FileBasedNPort('switch_file.s3p', interp_type='cubic')\nSWTCH.connect(p1,p2,p3)\nfs = hv.frange(0.001e9,0.1e9,1001)\nS = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S12,S.S13,S.S21,S.S22,S.S23,S.S31,S.S32,S.S33], labels=[f'S{i+1}{j+1}' for i in range(3) for j in range(3)])",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "p3",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "p3 = M.new_port(50)\nSWTCH = FileBasedNPort('switch_file.s3p', interp_type='cubic')\nSWTCH.connect(p1,p2,p3)\nfs = hv.frange(0.001e9,0.1e9,1001)\nS = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S12,S.S13,S.S21,S.S22,S.S23,S.S31,S.S32,S.S33], labels=[f'S{i+1}{j+1}' for i in range(3) for j in range(3)])",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "SWTCH",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "SWTCH = FileBasedNPort('switch_file.s3p', interp_type='cubic')\nSWTCH.connect(p1,p2,p3)\nfs = hv.frange(0.001e9,0.1e9,1001)\nS = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S12,S.S13,S.S21,S.S22,S.S23,S.S31,S.S32,S.S33], labels=[f'S{i+1}{j+1}' for i in range(3) for j in range(3)])",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "fs",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "fs = hv.frange(0.001e9,0.1e9,1001)\nS = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S12,S.S13,S.S21,S.S22,S.S23,S.S31,S.S32,S.S33], labels=[f'S{i+1}{j+1}' for i in range(3) for j in range(3)])",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 5,
        "importPath": "dev_scripts.touchstone_test",
        "description": "dev_scripts.touchstone_test",
        "peekOfCode": "S = M.run(fs)\nM.print_components()\nhv.plot_s_parameters(fs,[S.S11,S.S12,S.S13,S.S21,S.S22,S.S23,S.S31,S.S32,S.S33], labels=[f'S{i+1}{j+1}' for i in range(3) for j in range(3)])",
        "detail": "dev_scripts.touchstone_test",
        "documentation": {}
    },
    {
        "label": "BaseComponent",
        "kind": 6,
        "importPath": "src.heavi.lib.libgen",
        "description": "src.heavi.lib.libgen",
        "peekOfCode": "class BaseComponent:\n    def __init__(self):\n        self.network: Network = None\n        self.nodes: dict[int, Node] = {}\n        self.gnd: Node = None\n        self.n_nodes: int = 0\n        self.__post_init__()\n        self._selected_terminal: int = None\n    def __post_init__(self):\n        pass",
        "detail": "src.heavi.lib.libgen",
        "documentation": {}
    },
    {
        "label": "BaseTwoPort",
        "kind": 6,
        "importPath": "src.heavi.lib.libgen",
        "description": "src.heavi.lib.libgen",
        "peekOfCode": "class BaseTwoPort(BaseComponent):\n    def __post_init__(self):\n        self.n_nodes = 2\n    def __lt__(self, other: Node) -> BaseComponent:\n        if not isinstance(other, Node):\n            return NotImplemented\n        self.partial_connect(1, other)\n        return self\n    def __gt__(self, other: Node) -> Node:\n        if not isinstance(other, Node):",
        "detail": "src.heavi.lib.libgen",
        "documentation": {}
    },
    {
        "label": "BaseThreePort",
        "kind": 6,
        "importPath": "src.heavi.lib.libgen",
        "description": "src.heavi.lib.libgen",
        "peekOfCode": "class BaseThreePort(BaseComponent):\n    def __post_init__(self):\n        self.n_nodes = 3\nclass BaseFourPort(BaseComponent):\n    def __post_init__(self):\n        self.n_nodes = 4",
        "detail": "src.heavi.lib.libgen",
        "documentation": {}
    },
    {
        "label": "BaseFourPort",
        "kind": 6,
        "importPath": "src.heavi.lib.libgen",
        "description": "src.heavi.lib.libgen",
        "peekOfCode": "class BaseFourPort(BaseComponent):\n    def __post_init__(self):\n        self.n_nodes = 4",
        "detail": "src.heavi.lib.libgen",
        "documentation": {}
    },
    {
        "label": "Inductor",
        "kind": 6,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "class Inductor(BaseTwoPort):\n    def __init__(self, inductance: float, parasitic_capacitance: float = 0, parasitic_resistance: float = 0):\n        super().__init__()\n        self.inductance: float = inductance\n        self.parasitic_capacitance: float = parasitic_capacitance\n        self.parasitic_resistance: float = parasitic_resistance\n        self.component: Component = None\n    def __on_connect__(self):\n        pL = enforce_simparam(self.inductance)\n        pC = enforce_simparam(self.parasitic_capacitance)",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "Capacitor",
        "kind": 6,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "class Capacitor(BaseTwoPort):\n    def __init__(self, capacitance: float, parasitic_inductance: float = 0, parasitic_resistance: float = 0):\n        super().__init__()\n        self.capacitance: float = capacitance\n        self.parasitic_inductance: float = parasitic_inductance\n        self.parasitic_resistance: float = parasitic_resistance\n        self.component: Component = None\n    def __on_connect__(self):\n        pC = enforce_simparam(self.capacitance)\n        pL = enforce_simparam(self.parasitic_inductance)",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "Resistor",
        "kind": 6,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "class Resistor(BaseTwoPort):\n    def __init__(self, resistance: float, parasitic_capacitance: float = 0, parasitic_inductance: float = 0):\n        super().__init__()\n        self.resistance: float = resistance\n        self.component: Component = None\n        self.parasitic_capacitance: float = parasitic_capacitance\n        self.parasitic_inductance: float = parasitic_inductance\n    def __on_connect__(self):\n        pR = enforce_simparam(self.resistance)\n        pC = enforce_simparam(self.parasitic_capacitance)",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "Impedance",
        "kind": 6,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "class Impedance(BaseTwoPort):\n    def __init__(self, impedance: float | SimParam):\n        super().__init__()\n        self.impedance: SimParam = enforce_simparam(impedance)\n        self.component: Component = None\n    def __on_connect__(self):\n        self.component = self.network.impedance(self.node(1), self.node(2), self.impedance.inverse)\\\n                                                    .set_metadata(name='Lumped Impedance',\n                                                                  unit='',\n                                                                  value=self.impedance,",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "Admittance",
        "kind": 6,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "class Admittance(BaseTwoPort):\n    def __init__(self, admittance: float | SimParam):\n        super().__init__()\n        self.admittance: SimParam = enforce_simparam(admittance)\n        self.component: Component = None\n    def __on_connect__(self):\n        self.component = self.network.admittance(self.node(1), self.node(2), self.admittance)\\\n                                                    .set_metadata(name='Lumped Admittance',\n                                                                  unit='Siemens',\n                                                                  value=self.admittance,",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "TransmissionLineGrounded",
        "kind": 6,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "class TransmissionLineGrounded(BaseTwoPort):\n    def __init__(self, Z0: float, length: float, er: float = 1):\n        super().__init__()\n        self.Z0: float = Z0\n        self.er: float = er\n        self.length: float = length\n        self.component: Component = None\n    def __on_connect__(self):\n        pZ0 = enforce_simparam(self.Z0)\n        per = enforce_simparam(self.er)",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "TransmissionLine",
        "kind": 6,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "class TransmissionLine(BaseTwoPort):\n    def __init__(self, Z0: float, length: float, er: float = 1):\n        super().__init__()\n        self.Z0: float = Z0\n        self.er: float = er\n        self.length: float = length\n        self.component: Component = None\n    def __on_connect__(self):\n        pZ0 = enforce_simparam(self.Z0)\n        per = enforce_simparam(self.er)",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "L",
        "kind": 5,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "L = Inductor\nC = Capacitor\nZ = Impedance\nY = Admittance\nTL = TransmissionLine\nTLg = TransmissionLineGrounded\n# class StandardLinear(BaseRouter):\n#     def L(self, inductance: float, parasitic_capacitance: float = 0, parasitic_resistance: float = 0) -> Inductor:\n#         return Inductor(inductance, parasitic_capacitance, parasitic_resistance).attach(self.node)\n#     def C(self, capacitance: float, parasitic_inductance: float = 0, parasitic_resistance: float = 0) -> Capacitor:",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "C",
        "kind": 5,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "C = Capacitor\nZ = Impedance\nY = Admittance\nTL = TransmissionLine\nTLg = TransmissionLineGrounded\n# class StandardLinear(BaseRouter):\n#     def L(self, inductance: float, parasitic_capacitance: float = 0, parasitic_resistance: float = 0) -> Inductor:\n#         return Inductor(inductance, parasitic_capacitance, parasitic_resistance).attach(self.node)\n#     def C(self, capacitance: float, parasitic_inductance: float = 0, parasitic_resistance: float = 0) -> Capacitor:\n#         return Capacitor(capacitance, parasitic_inductance, parasitic_resistance).attach(self.node)",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "Z",
        "kind": 5,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "Z = Impedance\nY = Admittance\nTL = TransmissionLine\nTLg = TransmissionLineGrounded\n# class StandardLinear(BaseRouter):\n#     def L(self, inductance: float, parasitic_capacitance: float = 0, parasitic_resistance: float = 0) -> Inductor:\n#         return Inductor(inductance, parasitic_capacitance, parasitic_resistance).attach(self.node)\n#     def C(self, capacitance: float, parasitic_inductance: float = 0, parasitic_resistance: float = 0) -> Capacitor:\n#         return Capacitor(capacitance, parasitic_inductance, parasitic_resistance).attach(self.node)\n#     def R(self, resistance: float, parasitic_capacitance: float = 0, parasitic_inductance: float = 0) -> Resistor:",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "Y",
        "kind": 5,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "Y = Admittance\nTL = TransmissionLine\nTLg = TransmissionLineGrounded\n# class StandardLinear(BaseRouter):\n#     def L(self, inductance: float, parasitic_capacitance: float = 0, parasitic_resistance: float = 0) -> Inductor:\n#         return Inductor(inductance, parasitic_capacitance, parasitic_resistance).attach(self.node)\n#     def C(self, capacitance: float, parasitic_inductance: float = 0, parasitic_resistance: float = 0) -> Capacitor:\n#         return Capacitor(capacitance, parasitic_inductance, parasitic_resistance).attach(self.node)\n#     def R(self, resistance: float, parasitic_capacitance: float = 0, parasitic_inductance: float = 0) -> Resistor:\n#         return Resistor(resistance, parasitic_capacitance, parasitic_inductance).attach(self.node)",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "TL",
        "kind": 5,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "TL = TransmissionLine\nTLg = TransmissionLineGrounded\n# class StandardLinear(BaseRouter):\n#     def L(self, inductance: float, parasitic_capacitance: float = 0, parasitic_resistance: float = 0) -> Inductor:\n#         return Inductor(inductance, parasitic_capacitance, parasitic_resistance).attach(self.node)\n#     def C(self, capacitance: float, parasitic_inductance: float = 0, parasitic_resistance: float = 0) -> Capacitor:\n#         return Capacitor(capacitance, parasitic_inductance, parasitic_resistance).attach(self.node)\n#     def R(self, resistance: float, parasitic_capacitance: float = 0, parasitic_inductance: float = 0) -> Resistor:\n#         return Resistor(resistance, parasitic_capacitance, parasitic_inductance).attach(self.node)\n#     def Z(self, impedance: float | SimParam) -> Impedance:",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "TLg",
        "kind": 5,
        "importPath": "src.heavi.lib.lumped",
        "description": "src.heavi.lib.lumped",
        "peekOfCode": "TLg = TransmissionLineGrounded\n# class StandardLinear(BaseRouter):\n#     def L(self, inductance: float, parasitic_capacitance: float = 0, parasitic_resistance: float = 0) -> Inductor:\n#         return Inductor(inductance, parasitic_capacitance, parasitic_resistance).attach(self.node)\n#     def C(self, capacitance: float, parasitic_inductance: float = 0, parasitic_resistance: float = 0) -> Capacitor:\n#         return Capacitor(capacitance, parasitic_inductance, parasitic_resistance).attach(self.node)\n#     def R(self, resistance: float, parasitic_capacitance: float = 0, parasitic_inductance: float = 0) -> Resistor:\n#         return Resistor(resistance, parasitic_capacitance, parasitic_inductance).attach(self.node)\n#     def Z(self, impedance: float | SimParam) -> Impedance:\n#         return Impedance(impedance).attach(self.node)",
        "detail": "src.heavi.lib.lumped",
        "documentation": {}
    },
    {
        "label": "TransmissionLine",
        "kind": 6,
        "importPath": "src.heavi.lib.mc",
        "description": "src.heavi.lib.mc",
        "peekOfCode": "class TransmissionLine(BaseTwoPort):\n    def __init__(self, \n                 mcsim: MonteCarlo,\n                 length: float, \n                 Z0: float,\n                 VSWR: float = 1,\n                 er: float = 1,\n                 attenuation: float = 0,\n                 phase_stability: float = 0,\n                 amplitude_stability: float = 0,",
        "detail": "src.heavi.lib.mc",
        "documentation": {}
    },
    {
        "label": "CurrentFunction",
        "kind": 6,
        "importPath": "src.heavi.lib.nonlinear",
        "description": "src.heavi.lib.nonlinear",
        "peekOfCode": "class CurrentFunction(BaseComponent):\n    def __init__(self, function: Callable[[float], float]):\n        super().__init__()\n        self.n_nodes = 2\n        self.function: Callable[[float], float] = function\n        self.voltage: float = 0.5\n        self.eps: float = 1e-15\n    def get_voltage(self, V: np.ndarray) -> float:\n        i1 = self.node(1)\n        i2 = self.node(2)",
        "detail": "src.heavi.lib.nonlinear",
        "documentation": {}
    },
    {
        "label": "Diode",
        "kind": 6,
        "importPath": "src.heavi.lib.nonlinear",
        "description": "src.heavi.lib.nonlinear",
        "peekOfCode": "class Diode(CurrentFunction):\n    def __init__(self, Vt: float=0.0258, N=1.3497, I0: float = 1e-12, Rs = 0.13668):\n        def diode_current(voltage):\n            def equation(current):\n                return current - I0 * (np.exp((voltage.real - current * Rs) / (N * Vt)) - 1)\n            # Solve for I numerically (implicit equation)\n            I_sol = fsolve(equation, 0.1)  # Initial guess: 0\n            return I_sol\n        super().__init__(diode_current)",
        "detail": "src.heavi.lib.nonlinear",
        "documentation": {}
    },
    {
        "label": "OptimVar",
        "kind": 6,
        "importPath": "src.heavi.lib.optim",
        "description": "src.heavi.lib.optim",
        "peekOfCode": "class OptimVar(SimParam):\n    \"\"\" Class for defining an optimisation variable. \n    This class is used to define a variable that can be optimised. It is a subclass of SimParam, and can be used in the same way.\n    Parameters\n    ----------\n    initial_value : float\n        The initial value of the variable.\n    bounds : tuple[float, float], optional\n        The bounds of the variable. If not specified, the variable is unbounded.\n    mapping : Callable, optional",
        "detail": "src.heavi.lib.optim",
        "documentation": {}
    },
    {
        "label": "PNorm",
        "kind": 6,
        "importPath": "src.heavi.lib.optim",
        "description": "src.heavi.lib.optim",
        "peekOfCode": "class PNorm(Enum):\n    \"\"\" Enum for defining the type of norm to use in the optimisation.\n    This enum is used to define the type of norm to use in the optimisation. It can be used to specify the type of norm to use in the optimisation.\n    Attributes\n    ----------\n    MIN : int\n        The minimum norm.\n    MAX : int\n        The maximum norm.\n    P1 : int",
        "detail": "src.heavi.lib.optim",
        "documentation": {}
    },
    {
        "label": "Requirement",
        "kind": 6,
        "importPath": "src.heavi.lib.optim",
        "description": "src.heavi.lib.optim",
        "peekOfCode": "class Requirement(ABC):\n    \"\"\" Abstract class for defining a requirement.\n    This class is used to define a requirement for an optimiser. It is an abstract class, and should be subclassed to define a specific requirement.\n    \"\"\"\n    @abstractmethod\n    def eval(self, S: Sparameters) -> float:\n        pass\nclass FrequencyLevel(Requirement):\n    def __init__(self, \n                 fmin: float,",
        "detail": "src.heavi.lib.optim",
        "documentation": {}
    },
    {
        "label": "FrequencyLevel",
        "kind": 6,
        "importPath": "src.heavi.lib.optim",
        "description": "src.heavi.lib.optim",
        "peekOfCode": "class FrequencyLevel(Requirement):\n    def __init__(self, \n                 fmin: float,\n                 fmax: float,\n                 nF: int,\n                 sparam: tuple[int, int],\n                 upper_limit: float = None,\n                 lower_limit: float = None,\n                 weight: float = 1,\n                 f_norm: float | PNorm = 4):",
        "detail": "src.heavi.lib.optim",
        "documentation": {}
    },
    {
        "label": "Optimiser",
        "kind": 6,
        "importPath": "src.heavi.lib.optim",
        "description": "src.heavi.lib.optim",
        "peekOfCode": "class Optimiser:\n    \"\"\" Class for defining an optimiser.\n    This class is used to define an optimiser for a network. It is used to define the parameters to optimise, the requirements to meet, and the objective function to optimise.\n    Parameters\n    ----------\n    network : Network\n        The network to optimise.\n    \"\"\"\n    def __init__(self, network: Network):\n        self.network = network",
        "detail": "src.heavi.lib.optim",
        "documentation": {}
    },
    {
        "label": "generalized_mean",
        "kind": 2,
        "importPath": "src.heavi.lib.optim",
        "description": "src.heavi.lib.optim",
        "peekOfCode": "def generalized_mean(norm: float) -> Callable:\n    \"\"\" Generate a generalized mean function.\n    This function generates a generalized mean function with the specified norm.\n    Parameters\n    ----------\n    norm : float\n        The norm of the mean.\n    Returns\n    -------\n    Callable",
        "detail": "src.heavi.lib.optim",
        "documentation": {}
    },
    {
        "label": "dBbelow",
        "kind": 2,
        "importPath": "src.heavi.lib.optim",
        "description": "src.heavi.lib.optim",
        "peekOfCode": "def dBbelow(dB_level: float,\n            norm: float | PNorm = PNorm.P2) -> Callable:\n    \"\"\" Generate a function that calculates the dB level below a specified level.\n    This function generates a function that calculates the dB level below a specified level.\n    Parameters\n    ----------\n    dB_level : float\n        The dB level to calculate the level below.\n    norm : float | PNorm, optional\n        The norm to use in the calculation. If not specified, the P2 norm is used.",
        "detail": "src.heavi.lib.optim",
        "documentation": {}
    },
    {
        "label": "dBabove",
        "kind": 2,
        "importPath": "src.heavi.lib.optim",
        "description": "src.heavi.lib.optim",
        "peekOfCode": "def dBabove(dB_level: float,\n            norm: float | PNorm = PNorm.P2) -> Callable:\n    \"\"\" Generate a function that calculates the dB level above a specified level.\n    This function generates a function that calculates the dB level above a specified level.\n    Parameters\n    ----------\n    dB_level : float\n        The dB level to calculate the level above.\n    norm : float | PNorm, optional\n        The norm to use in the calculation. If not specified, the P2 norm is used.",
        "detail": "src.heavi.lib.optim",
        "documentation": {}
    },
    {
        "label": "MicrostripLine",
        "kind": 6,
        "importPath": "src.heavi.lib.pcb",
        "description": "src.heavi.lib.pcb",
        "peekOfCode": "class MicrostripLine(BaseComponent):\n    def __init__(self, width: float, length: float, height: float, epsilon_r: float, tand: float, trace_thickenss: float = 60e-6, gnd: Node = None):\n        super().__init__()\n        self.width: float = width\n        self.length: float = length\n        self.height: float = height\n        self.ereff: float = _microstrip_ereff(width, height, epsilon_r, trace_thickenss)\n        self.Z0: float = _microstrip_z0(width, height, epsilon_r, trace_thickenss)\n        self.tand: float = tand\n        self.gnd: Node = gnd",
        "detail": "src.heavi.lib.pcb",
        "documentation": {}
    },
    {
        "label": "Stripline",
        "kind": 6,
        "importPath": "src.heavi.lib.pcb",
        "description": "src.heavi.lib.pcb",
        "peekOfCode": "class Stripline(BaseComponent):\n    def __init__(self, width: float, length: float, height: float, epsilon_r: float, tand: float, trace_thickenss: float = 60e-6, gnd: Node = None):\n        super().__init__()\n        self.width: float = width\n        self.length: float = length\n        self.height: float = height\n        self.ereff: float = _stripline_ereff(width, height, epsilon_r, trace_thickenss)\n        self.Z0: float = _stripline_z0(width, height, epsilon_r, trace_thickenss)\n        self.tand: float = tand\n        self.gnd: Node = gnd",
        "detail": "src.heavi.lib.pcb",
        "documentation": {}
    },
    {
        "label": "Path",
        "kind": 6,
        "importPath": "src.heavi.lib.pcb",
        "description": "src.heavi.lib.pcb",
        "peekOfCode": "class Path:\n    def __init__(self, start_node: Node):\n        self.start_node = start_node\n        self.component_link: list = []\n    @property\n    def last(self):\n        return self.component_link[-1]\n    @property\n    def first(self):\n        return len(self.component_link)",
        "detail": "src.heavi.lib.pcb",
        "documentation": {}
    },
    {
        "label": "PCBStack",
        "kind": 6,
        "importPath": "src.heavi.lib.pcb",
        "description": "src.heavi.lib.pcb",
        "peekOfCode": "class PCBStack:\n    def __init__(self, network: Network, epsilon_r: float, tand: float, thickness: float, Nlayers: int):\n        # Test that the layers are at least 2 and at most 10\n        if Nlayers < 2 or Nlayers > 10:\n            raise ValueError(\"The number of layers must be at least 2 and at most 10\")\n        # Test that the thickness is positive\n        if thickness <= 0:\n            raise ValueError(\"The thickness must be positive\")\n        # Test that the relative permittivity is positive\n        if epsilon_r <= 0:",
        "detail": "src.heavi.lib.pcb",
        "documentation": {}
    },
    {
        "label": "NodeForwarder",
        "kind": 6,
        "importPath": "src.heavi.lib.pcb",
        "description": "src.heavi.lib.pcb",
        "peekOfCode": "class NodeForwarder:\n    def __init__(self, node: Node, layer: int, pcb: PCBStack, impedance: float):\n        self.node: Node = node\n        self.layer: int = layer\n        self.pcb: PCBStack = pcb\n        self.impedance: float = impedance\n    def terminate(self, Z0: float) -> Node:\n        \"\"\" Terminate the path with a resistor. \"\"\"\n        return self.pcb.network.terminal(self.node, Z0).output_node\n    def straight(self, L: float, Z0: float = None, width: float = None) -> NodeForwarder:",
        "detail": "src.heavi.lib.pcb",
        "documentation": {}
    },
    {
        "label": "MultiNodeForwarder",
        "kind": 6,
        "importPath": "src.heavi.lib.pcb",
        "description": "src.heavi.lib.pcb",
        "peekOfCode": "class MultiNodeForwarder:\n    def __init__(self, nfs: list[NodeForwarder]):\n        self.nfs: list[NodeForwarder] = nfs\n    def __call__(self, index: int) -> NodeForwarder:\n        # check the integer range\n        if index < 0 or index >= len(self.nfs):\n            raise ValueError(\"The index must be between 0 and the number of nodes - 1\")\n        return self.nfs[index]",
        "detail": "src.heavi.lib.pcb",
        "documentation": {}
    },
    {
        "label": "coth",
        "kind": 2,
        "importPath": "src.heavi.lib.pcb",
        "description": "src.heavi.lib.pcb",
        "peekOfCode": "def coth(x):\n    return -np.tan(x + np.pi/2)\ndef _microstrip_ereff(w: float, h: float, er: float, t: float):\n    u = w/h\n    T = t/h\n    du1 = T/np.pi * np.log(1 + 4*np.exp(1)/(T*coth(6.517*u)**2))\n    dur = 1/2 * (1 + 1/np.cosh(er -1 )) * du1\n    u = u + dur\n    a = 1 + (1/49) * np.log((u**4 + (u/52)**2)/(u**4 + 0.432)) + (1/18.7) * np.log(1 + (u/18.1)**3)\n    b = 0.564 * ((er - 0.9) / (er + 3))**0.053",
        "detail": "src.heavi.lib.pcb",
        "documentation": {}
    },
    {
        "label": "u0",
        "kind": 5,
        "importPath": "src.heavi.lib.pcb",
        "description": "src.heavi.lib.pcb",
        "peekOfCode": "u0 = 4*np.pi*1e-7\ndef coth(x):\n    return -np.tan(x + np.pi/2)\ndef _microstrip_ereff(w: float, h: float, er: float, t: float):\n    u = w/h\n    T = t/h\n    du1 = T/np.pi * np.log(1 + 4*np.exp(1)/(T*coth(6.517*u)**2))\n    dur = 1/2 * (1 + 1/np.cosh(er -1 )) * du1\n    u = u + dur\n    a = 1 + (1/49) * np.log((u**4 + (u/52)**2)/(u**4 + 0.432)) + (1/18.7) * np.log(1 + (u/18.1)**3)",
        "detail": "src.heavi.lib.pcb",
        "documentation": {}
    },
    {
        "label": "SMDResistorSize",
        "kind": 6,
        "importPath": "src.heavi.lib.smd",
        "description": "src.heavi.lib.smd",
        "peekOfCode": "class SMDResistorSize(Enum):\n    R0402 = \"0402\"\n    R0603 = \"0603\"\n    R0805 = \"0805\"\n    R1206 = \"1206\"\n    # Add other sizes as needed\nclass SMDCapacitorSize(Enum):\n    C0402 = \"0402\"\n    C0603 = \"0603\"\n    C0805 = \"0805\"",
        "detail": "src.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "SMDCapacitorSize",
        "kind": 6,
        "importPath": "src.heavi.lib.smd",
        "description": "src.heavi.lib.smd",
        "peekOfCode": "class SMDCapacitorSize(Enum):\n    C0402 = \"0402\"\n    C0603 = \"0603\"\n    C0805 = \"0805\"\n    C1206 = \"1206\"\n    # Add other sizes as needed\nclass SMDInductorSize(Enum):\n    L0402 = \"0402\"\n    L0603 = \"0603\"\n    L0805 = \"0805\"",
        "detail": "src.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "SMDInductorSize",
        "kind": 6,
        "importPath": "src.heavi.lib.smd",
        "description": "src.heavi.lib.smd",
        "peekOfCode": "class SMDInductorSize(Enum):\n    L0402 = \"0402\"\n    L0603 = \"0603\"\n    L0805 = \"0805\"\n    L1206 = \"1206\"\n    # Add other sizes as needed\nclass SMDResistor(BaseTwoPort):\n    \"\"\"\n    A simple SMD resistor model that accounts for parasitic inductance and capacitance \n    based on package size.",
        "detail": "src.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "SMDResistor",
        "kind": 6,
        "importPath": "src.heavi.lib.smd",
        "description": "src.heavi.lib.smd",
        "peekOfCode": "class SMDResistor(BaseTwoPort):\n    \"\"\"\n    A simple SMD resistor model that accounts for parasitic inductance and capacitance \n    based on package size.\n    Attributes\n    ----------\n    resistance : float\n        The resistance value in ohms.\n    inductance : float\n        The parasitic inductance in henries.",
        "detail": "src.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "SMDInductor",
        "kind": 6,
        "importPath": "src.heavi.lib.smd",
        "description": "src.heavi.lib.smd",
        "peekOfCode": "class SMDInductor(BaseTwoPort):\n    \"\"\"\n    An SMD inductor with a simple R-L // C parasitic model.\n    - The inductor has a series ESR (Equivalent Series Resistance) with the inductance.\n    - A small parallel capacitance accounts for high-frequency behavior.\n    Attributes\n    ----------\n    inductance : float\n        The nominal inductance value in henries (H).\n    esr : float",
        "detail": "src.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "SMDCapacitor",
        "kind": 6,
        "importPath": "src.heavi.lib.smd",
        "description": "src.heavi.lib.smd",
        "peekOfCode": "class SMDCapacitor(BaseTwoPort):\n    \"\"\"\n    An SMD capacitor with an ESL-ESR-C series model.\n    Attributes\n    ----------\n    capacitance : float\n        The nominal capacitance value in farads (F).\n    esr : float\n        The equivalent series resistance in ohms ().\n    esl : float",
        "detail": "src.heavi.lib.smd",
        "documentation": {}
    },
    {
        "label": "#NAME#",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class #NAME#(BaseTwoPort):\n    \"\"\" #DESCRIPTION# \"\"\"\n    def __init__(self):\n        super().__init__()\n    def __on_connect__(self):\n        node1 = self.node(1)\n        node2 = self.node(2)\n#NODES#\n#REST#'''\n_PYTHON_BASE_TEMPLATE = '''",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "SpaceCompContainer",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class SpaceCompContainer:\n    _implemented: bool = False\n    def __init__(self, name: str, nodes: List[int], value: float):\n        self.name = name\n        self.nodes = nodes\n        self.value = value\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(name={self.name}, nodes={self.nodes}, value={self.value})\"\nclass SpiceR(SpaceCompContainer):\n    _implemented: bool = True",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "SpiceR",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class SpiceR(SpaceCompContainer):\n    _implemented: bool = True\nclass SpiceL(SpaceCompContainer):\n    _implemented: bool = True\nclass SpiceC(SpaceCompContainer):\n    _implemented: bool = True\nclass SpiceV(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceI(SpaceCompContainer):\n    _implemented: bool = False",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "SpiceL",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class SpiceL(SpaceCompContainer):\n    _implemented: bool = True\nclass SpiceC(SpaceCompContainer):\n    _implemented: bool = True\nclass SpiceV(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceI(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceX(SpaceCompContainer):\n    _implemented: bool = False",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "SpiceC",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class SpiceC(SpaceCompContainer):\n    _implemented: bool = True\nclass SpiceV(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceI(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceX(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceD(SpaceCompContainer):\n    _implemented: bool = False",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "SpiceV",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class SpiceV(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceI(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceX(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceD(SpaceCompContainer):\n    _implemented: bool = False\nclass Subcircuit:\n    def __init__(self, name: str, nodes: List[int], components: List[SpaceCompContainer]):",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "SpiceI",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class SpiceI(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceX(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceD(SpaceCompContainer):\n    _implemented: bool = False\nclass Subcircuit:\n    def __init__(self, name: str, nodes: List[int], components: List[SpaceCompContainer]):\n        self.name = name\n        self.nodes = nodes",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "SpiceX",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class SpiceX(SpaceCompContainer):\n    _implemented: bool = False\nclass SpiceD(SpaceCompContainer):\n    _implemented: bool = False\nclass Subcircuit:\n    def __init__(self, name: str, nodes: List[int], components: List[SpaceCompContainer]):\n        self.name = name\n        self.nodes = nodes\n        self.components = components\n    def __repr__(self):",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "SpiceD",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class SpiceD(SpaceCompContainer):\n    _implemented: bool = False\nclass Subcircuit:\n    def __init__(self, name: str, nodes: List[int], components: List[SpaceCompContainer]):\n        self.name = name\n        self.nodes = nodes\n        self.components = components\n    def __repr__(self):\n        return f\"Subcircuit(name={self.name}, nodes={self.nodes}, components={self.components})\"\n    @property",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "Subcircuit",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class Subcircuit:\n    def __init__(self, name: str, nodes: List[int], components: List[SpaceCompContainer]):\n        self.name = name\n        self.nodes = nodes\n        self.components = components\n    def __repr__(self):\n        return f\"Subcircuit(name={self.name}, nodes={self.nodes}, components={self.components})\"\n    @property\n    def is_supported(self) -> bool:\n        ''' Returns True if all components in the subcircuit are supported by the compiler. '''",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "SpiceASY",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class SpiceASY:\n    def __init__(self, description: list[str], spicemodel: str, instname: str, model_file: str):\n        self.description = description\n        self.spicemodel = spicemodel\n        self.instname = instname\n        self.model_file = model_file\n        if self.instname is None:\n            self.instname = 'unnamed'\n        if self.model_file is None:\n            self.model_file = 'unnamed'",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "SpiceComponent",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class SpiceComponent(BaseTwoPort):\n    def __init__(self, subcircuit: Subcircuit):\n        super().__init__()\n        self.subcircuit = subcircuit\n    def add_component(self, component: SpaceCompContainer, node1: Node, node2: Node):\n        value = component.value\n        if isinstance(component, SpiceR):\n            self.network.resistor(node1, node2, value)\n        elif isinstance(component, SpiceL):\n            self.network.inductor(node1, node2, value)",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "SpiceLibrary",
        "kind": 6,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "class SpiceLibrary:\n    def __init__(self, filepath: str):\n        self.filepath = filepath\n        self.subcircuits: list[Subcircuit] = parse_spice_lib(filepath)\n        self.circuit_dict: dict[str, Subcircuit] = {subckt.name.lower(): subckt for subckt in self.subcircuits}\n    def merge(self, other: SpiceLibrary) -> SpiceLibrary:\n        ''' Merge another SpiceLibrary objects into the current one. '''\n        self.subcircuits.extend(other.subcircuits)\n        self.circuit_dict.update(other.circuit_dict)\n        return self",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "merge_continuation_lines",
        "kind": 2,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "def merge_continuation_lines(file_path: str) -> List[str]:\n    \"\"\"\n    Reads the file and merges lines that begin with '+' with the previous line.\n    \"\"\"\n    merged_lines = []\n    with open(file_path, 'r', encoding='utf-8', errors='replace') as f:\n        current_line = \"\"\n        for line in f:\n            # Remove trailing newline and spaces.\n            line = line.rstrip()",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "parse_token",
        "kind": 2,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "def parse_token(string: str, numdict: dict) -> float:\n    ''' Parses a string with a number and a power of 10. '''\n    if string[0] == \"{\" and string[-1] == \"}\":\n        return numdict.get(string[1:-1], None)\n    else:\n        string = re.sub(r'(?i)\\bmeg\\b', 'M', string)\n        groups = re.match(r'([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)([a-zA-Z]?)([a-zA-Z]*)?', string)\n        # Groups is Number, potential power and unit. Units are ignored\n        if groups is None:\n            raise ValueError(f\"Invalid number: {string}, {numdict}\")",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "parse_subckt_line",
        "kind": 2,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "def parse_subckt_line(line: str) -> Subcircuit:\n    # Remove excess spaces and normalize whitespace\n    line = re.sub(r\"\\s+\", \" \", line.strip()).upper()\n    # Match the .subckt line structure\n    match = re.match(r\"\\.SUBCKT\\s+([a-zA-Z\\d\\-\\_\\.\\+]+)\\s+([0-9a-zA-Z\\s]+)(?:\\s+PARAMS:\\s*(.*))?\", line)\n    if not match:\n        raise ValueError(f\"Invalid .subckt line: {line}\")\n    name = match.group(1)  # Subcircuit name\n    nodes = list(match.group(2).split()) # Convert nodes to integers\n    params_str = match.group(3) if match.group(3) else \"\"  # Parameter string",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "parse_spice_lib",
        "kind": 2,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "def parse_spice_lib(file_path: str) -> List[Subcircuit]:\n    \"\"\"\n    Parses a SPICE .lib file (with or without continuation lines)\n    and returns a list of Subcircuit objects ONLY if the subcircuit contains\n    components whose names begin with R, L, C, V, or I.\n    Each Subcircuit object contains:\n      - name: the subcircuit name (from the .subckt header)\n      - nodes: the list of nodes declared in the header\n      - components: a list of component objects (SpiceR, SpiceL, SpiceC, etc.)\n    If any component in the subcircuit does not begin with one of the allowed",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "import_spice_library_directory",
        "kind": 2,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "def import_spice_library_directory(directory: str, libfilename: str = None) -> None:\n    ''' This function searches all .lib files in the provided directory to build one big SpiceLibrary object.\n    Then it searches foor all spice .asy files to generate a set of components. \n    Based on this it generates a Python file with the components and the SpiceLibrary object. '''\n    lib_files = Path(directory).rglob(\"*.lib\")\n    asy_files = Path(directory).rglob(\"*.asy\")\n    spicelib = SpiceLibrary(next(lib_files))\n    for file in lib_files:\n        spicelib.merge(SpiceLibrary(file))\n    asys = [_parse_asy_file(file) for file in asy_files]",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "_POWERS",
        "kind": 5,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "_POWERS = {\n        \"f\": -15,\n        \"p\": -12,\n        \"n\": -9,\n        \"u\": -6,\n        \"m\": -3,\n        \"k\": 3,\n        \"q\": 6,\n        \"g\": 9,\n        \"t\": 12,",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "_PYTHON_BASE_TEMPLATE",
        "kind": 5,
        "importPath": "src.heavi.lib.spice",
        "description": "src.heavi.lib.spice",
        "peekOfCode": "_PYTHON_BASE_TEMPLATE = '''\nfrom __future__ import annotations\nfrom heavi.lib.libgen import BaseTwoPort\nfrom heavi.rfcircuit import Node\n'''\n# Define basic component classes.\nclass SpaceCompContainer:\n    _implemented: bool = False\n    def __init__(self, name: str, nodes: List[int], value: float):\n        self.name = name",
        "detail": "src.heavi.lib.spice",
        "documentation": {}
    },
    {
        "label": "Wilkinson",
        "kind": 6,
        "importPath": "src.heavi.lib.tl",
        "description": "src.heavi.lib.tl",
        "peekOfCode": "class Wilkinson(BaseThreePort):\n    def __init__(self, Z0: float | SimParam, fc: float | SimParam, er: float | SimParam = 1):\n        super().__init__()\n        self.Z0 = Z0\n        self.fc = fc\n        self.er = er\n    def __on_connect__(self):\n        wavelength = 299792458 / (self.fc*np.sqrt(self.er))\n        def beta(f):\n            return 2*np.pi*f*np.sqrt(self.er)/(299792458)",
        "detail": "src.heavi.lib.tl",
        "documentation": {}
    },
    {
        "label": "BranchlineCoupler",
        "kind": 6,
        "importPath": "src.heavi.lib.tl",
        "description": "src.heavi.lib.tl",
        "peekOfCode": "class BranchlineCoupler(BaseFourPort):\n    def __init__(self, Z0: float | SimParam, fc: float | SimParam, er: float | SimParam = 1):\n        super().__init__()\n        self.Z0 = Z0\n        self.fc = fc\n        self.er = er\n    def __on_connect__(self):\n        wavelength = 299792458 / (self.fc*np.sqrt(self.er))\n        L = wavelength / 4\n        def beta(f):",
        "detail": "src.heavi.lib.tl",
        "documentation": {}
    },
    {
        "label": "RatraceCoupler",
        "kind": 6,
        "importPath": "src.heavi.lib.tl",
        "description": "src.heavi.lib.tl",
        "peekOfCode": "class RatraceCoupler(BaseFourPort):\n    def __init__(self, Z0: float | SimParam, fc: float | SimParam, er: float | SimParam = 1):\n        super().__init__()\n        self.Z0 = Z0\n        self.fc = fc\n        self.er = er\n    def __on_connect__(self):\n        wavelength = 299792458 / (self.fc*np.sqrt(self.er))\n        L = wavelength / 4\n        def beta(f):",
        "detail": "src.heavi.lib.tl",
        "documentation": {}
    },
    {
        "label": "Transformer",
        "kind": 6,
        "importPath": "src.heavi.lib.tl",
        "description": "src.heavi.lib.tl",
        "peekOfCode": "class Transformer(BaseTwoPort):\n    def __init__(self, \n                 Z1: float | SimParam,\n                 Z2: float | SimParam,\n                 fc: float | SimParam, \n                 N_sections: int = 1,\n                 ripple: float | SimParam = 0.05,\n                 er: float | SimParam = 1):\n        super().__init__()\n        self.Z1 = Z1",
        "detail": "src.heavi.lib.tl",
        "documentation": {}
    },
    {
        "label": "FileBasedNPort",
        "kind": 6,
        "importPath": "src.heavi.lib.touchstone",
        "description": "src.heavi.lib.touchstone",
        "peekOfCode": "class FileBasedNPort(BaseComponent):\n    def __init__(self, filename: str,\n                 n_ports: int = None,\n                 ignore_extension: bool = False,\n                 interp_type: str = 'cubic'):\n        super().__init__()\n        path = Path(filename)\n        if not path.exists():\n            raise ValueError(f'The provided filename {path} does not exist.')\n        if path.suffix not in ('.s1p','.s2p','.s3p','.s4p','.snp','.ts') and not ignore_extension:",
        "detail": "src.heavi.lib.touchstone",
        "documentation": {}
    },
    {
        "label": "_FUNIT",
        "kind": 5,
        "importPath": "src.heavi.lib.touchstone",
        "description": "src.heavi.lib.touchstone",
        "peekOfCode": "_FUNIT = {\n    'hz': 1,\n    'khz': 1000,\n    'mhz': 1e6,\n    'ghz': 1e9,\n}\n_NPORTS = {\n    '.s1p': 1,\n    '.s2p': 2,\n    '.s3p': 3,",
        "detail": "src.heavi.lib.touchstone",
        "documentation": {}
    },
    {
        "label": "_NPORTS",
        "kind": 5,
        "importPath": "src.heavi.lib.touchstone",
        "description": "src.heavi.lib.touchstone",
        "peekOfCode": "_NPORTS = {\n    '.s1p': 1,\n    '.s2p': 2,\n    '.s3p': 3,\n    '.s4p': 4,\n    '.snp': None\n}\ndef _ma_ri(mag: float, angle: float) -> complex:\n    return mag * np.exp(1j * np.radians(angle))\ndef _db_ri(db: float, angle: float) -> complex:",
        "detail": "src.heavi.lib.touchstone",
        "documentation": {}
    },
    {
        "label": "_DATAMAP",
        "kind": 5,
        "importPath": "src.heavi.lib.touchstone",
        "description": "src.heavi.lib.touchstone",
        "peekOfCode": "_DATAMAP = {\n    'ma': _ma_ri,\n    'db': _db_ri,\n    'ri': _ri_ri\n}\nclass FileBasedNPort(BaseComponent):\n    def __init__(self, filename: str,\n                 n_ports: int = None,\n                 ignore_extension: bool = False,\n                 interp_type: str = 'cubic'):",
        "detail": "src.heavi.lib.touchstone",
        "documentation": {}
    },
    {
        "label": "FilterType",
        "kind": 6,
        "importPath": "src.heavi.filtering",
        "description": "src.heavi.filtering",
        "peekOfCode": "class FilterType(Enum):\n    \"\"\"Filter type enumeration.\n    This enumeration is used to specify the type of filter to create.\n    constants:\n    -----------\n    CHEBYCHEV : int\n        Chebyshev filter.\n    BUTTERWORTH : int\n    \"\"\"\n    CHEBYCHEV = 1",
        "detail": "src.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "BandType",
        "kind": 6,
        "importPath": "src.heavi.filtering",
        "description": "src.heavi.filtering",
        "peekOfCode": "class BandType(Enum):\n    \"\"\"Band type enumeration.\n    This enumeration is used to specify the type of band to create.\n    constants:\n    -----------\n    HIGHPASS : int\n        Highpass filter.\n    LOWPASS : int\n        Lowpass filter.\n    BANDPASS : int",
        "detail": "src.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "CauerType",
        "kind": 6,
        "importPath": "src.heavi.filtering",
        "description": "src.heavi.filtering",
        "peekOfCode": "class CauerType(Enum):\n    \"\"\"Cauer type enumeration.\n    constants:\n    -----------\n    TYPE1 : int\n        Type 1 Passband ripple\n    TYPE2 : int\n        Type 2 Stopband ripple\n    \"\"\"\n    TYPE1 = 1",
        "detail": "src.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "Filtering",
        "kind": 6,
        "importPath": "src.heavi.filtering",
        "description": "src.heavi.filtering",
        "peekOfCode": "class Filtering:\n    def __init__(self, N: Network):\n        self.N = N \n    def impedance_transformer(self,\n                              gnd: Node,\n                              port1: Node,\n                              port2: Node,\n                              Z01: float,\n                              Z02: float,\n                              fc: float = None,",
        "detail": "src.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "even",
        "kind": 2,
        "importPath": "src.heavi.filtering",
        "description": "src.heavi.filtering",
        "peekOfCode": "def even(x):\n    \"\"\" Returns True if x is even, False otherwise. \"\"\"\n    if x % 2 == 0:\n        return True\n    return False\ndef odd(x):\n    \"\"\" Returns True if x is odd, False otherwise. \"\"\"\n    if x % 2 == 1:\n        return True\n    return False",
        "detail": "src.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "odd",
        "kind": 2,
        "importPath": "src.heavi.filtering",
        "description": "src.heavi.filtering",
        "peekOfCode": "def odd(x):\n    \"\"\" Returns True if x is odd, False otherwise. \"\"\"\n    if x % 2 == 1:\n        return True\n    return False\nclass FilterType(Enum):\n    \"\"\"Filter type enumeration.\n    This enumeration is used to specify the type of filter to create.\n    constants:\n    -----------",
        "detail": "src.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "prototype_chebychev",
        "kind": 2,
        "importPath": "src.heavi.filtering",
        "description": "src.heavi.filtering",
        "peekOfCode": "def prototype_chebychev(order: int, ripple: float) -> tuple[np.ndarray, float]:\n    \"\"\"Generates the Chebyshev prototype filter G-coefficients.\n    Parameters\n    ----------\n    order : int\n        The order of the filter.\n    ripple : float\n        The ripple factor in dB.\n    Returns\n    -------",
        "detail": "src.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "prototype_butterworth",
        "kind": 2,
        "importPath": "src.heavi.filtering",
        "description": "src.heavi.filtering",
        "peekOfCode": "def prototype_butterworth(order: int) -> tuple[np.ndarray, float]:\n    \"\"\"Generates the Butterworth prototype filter G-coefficients.\n    Parameters\n    ----------\n    order : int\n        The order of the filter.\n    Returns\n    -------\n    tuple\n        A tuple containing the G-coefficients and the load impedance scaler (for generality, the scaler is always 1)",
        "detail": "src.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "gen_cheb_poly",
        "kind": 2,
        "importPath": "src.heavi.filtering",
        "description": "src.heavi.filtering",
        "peekOfCode": "def gen_cheb_poly(n: int):\n    \"\"\"Generates the nth order Chebyshev polynomial.\"\"\"\n    x = sym.symbols('x')\n    if n==0:\n        output = 1\n    elif n==1:\n        T1 = x\n        output = T1\n    else:\n        Tnm1 = x",
        "detail": "src.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "impedance_transformer_cheb",
        "kind": 2,
        "importPath": "src.heavi.filtering",
        "description": "src.heavi.filtering",
        "peekOfCode": "def impedance_transformer_cheb(Z1: float, Z2: float, A: float, N: int):\n    \"\"\"Generates the impedances for an impedance transformer using Chebyshev polynomials.\n    Parameters:\n    -----------\n    Z1 : float\n        The characteristic impedance of the first port.\n    Z2 : float\n        The characteristic impedance of the second port.\n    A : float\n        The ripple factor in dB.",
        "detail": "src.heavi.filtering",
        "documentation": {}
    },
    {
        "label": "hintersections",
        "kind": 2,
        "importPath": "src.heavi.graphing",
        "description": "src.heavi.graphing",
        "peekOfCode": "def hintersections(x, y, level):\n    y1 = y[:-1] - level\n    y2 = y[1:] - level\n    ycross = y1 * y2\n    id1 = np.where(ycross < 0)[0]\n    id2 = id1 + 1\n    x1 = x[id1]\n    x2 = x[id2]\n    y1 = y[id1] - level\n    y2 = y[id2] - level",
        "detail": "src.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "plot",
        "kind": 2,
        "importPath": "src.heavi.graphing",
        "description": "src.heavi.graphing",
        "peekOfCode": "def plot(x: np.ndarray, y: np.ndarray) -> None:\n    \"\"\"Simple wrapper for an x-y plot\n    Parameters\n    ----------\n    x : np.ndarray\n        x-axis values\n    y : np.ndarray\n        y-axis values\n    \"\"\"\n    fig, ax = plt.subplots()",
        "detail": "src.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "smith",
        "kind": 2,
        "importPath": "src.heavi.graphing",
        "description": "src.heavi.graphing",
        "peekOfCode": "def smith(f, S):\n    if not isinstance(S, list):\n        Ss = [S]\n    else:\n        Ss = S\n    fig, ax = plt.subplots()\n    for line in _smith_transform(_generate_grids()):\n        ax.plot(line[0], line[1], color='grey', alpha=0.3, linewidth=0.7)\n    p = np.linspace(0,2*np.pi,101)\n    ax.plot(np.cos(p), np.sin(p), color='black', alpha=0.5)",
        "detail": "src.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "plot_s_parameters",
        "kind": 2,
        "importPath": "src.heavi.graphing",
        "description": "src.heavi.graphing",
        "peekOfCode": "def plot_s_parameters(f, S, dblim=[-80, 5], \n               xunit=\"GHz\", \n               levelindicator: int | float =None, \n               noise_floor=-150, \n               fill_areas: list[tuple]= None, \n               spec_area: list[tuple[float]] = None,\n               unwrap_phase=False, \n               logx: bool = False,\n               labels: list[str] = None,\n               linestyles: list[str] = None,",
        "detail": "src.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "_colors",
        "kind": 5,
        "importPath": "src.heavi.graphing",
        "description": "src.heavi.graphing",
        "peekOfCode": "_colors = plt.rcParams['axes.prop_cycle'].by_key()['color']\nggplot_styles = {\n    \"axes.edgecolor\": \"000000\",\n    \"axes.facecolor\": \"F2F2F2\",\n    \"axes.grid\": True,\n    \"axes.grid.which\": \"both\",\n    \"axes.spines.left\": True,\n    \"axes.spines.right\": True,\n    \"axes.spines.top\": True,\n    \"axes.spines.bottom\": True,",
        "detail": "src.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "ggplot_styles",
        "kind": 5,
        "importPath": "src.heavi.graphing",
        "description": "src.heavi.graphing",
        "peekOfCode": "ggplot_styles = {\n    \"axes.edgecolor\": \"000000\",\n    \"axes.facecolor\": \"F2F2F2\",\n    \"axes.grid\": True,\n    \"axes.grid.which\": \"both\",\n    \"axes.spines.left\": True,\n    \"axes.spines.right\": True,\n    \"axes.spines.top\": True,\n    \"axes.spines.bottom\": True,\n    \"grid.color\": \"A0A0A0\",",
        "detail": "src.heavi.graphing",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 6,
        "importPath": "src.heavi.model",
        "description": "src.heavi.model",
        "peekOfCode": "class Model(Network):\n    def __init__(self, default_name: str = \"Node\", \n                 filter_library: Filtering = Filtering, \n                 suppress_loadbar: bool = False):\n        super().__init__(default_name, suppress_loadbar=suppress_loadbar)\n        self.filters: Filtering = filter_library(self)\n        self.numbered_nodes: dict[int, Node] = dict()\n    def __call__(self, index: int) -> Node:\n        if index not in self.numbered_nodes:\n            self.numbered_nodes[index] = self.node()",
        "detail": "src.heavi.model",
        "documentation": {}
    },
    {
        "label": "QuickModel",
        "kind": 6,
        "importPath": "src.heavi.model",
        "description": "src.heavi.model",
        "peekOfCode": "class QuickModel(Network):\n    def __init__(self, default_name: str = \"Node\", \n                 filter_library: Filtering = Filtering, \n                 suppress_loadbar: bool = False):\n        super().__init__(default_name, suppress_loadbar=suppress_loadbar)\n        self.filters: Filtering = filter_library(self)\n    def LC(self, n1: Node, n2: Node, L: float, C: float) -> None:\n        self.capacitor(n1, n2, C)\n        self.inductor(n1, n2, L)\n    def LC_series(self, n1: Node, n2: Node, L: float, C: float) -> None:",
        "detail": "src.heavi.model",
        "documentation": {}
    },
    {
        "label": "Uninitialized",
        "kind": 6,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "class Uninitialized:\n    \"\"\"A class to represent an uninitialized value\"\"\"\n    def __init__(self):\n        pass\n    def __repr__(self):\n        return \"Uninitialized\"\n    def __call__(self, f):\n        raise ValueError(\"Uninitialized value\")\n    def __mul__(self, other):\n        raise ValueError(\"Uninitialized value\")",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "SimParam",
        "kind": 6,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "class SimParam:\n    _eval_f = 1e9\n    def __init__(self, unit=''):\n        self.unit = ''\n        self._inf = np.inf\n    @property\n    def value(self) -> float:\n        return self(0)\n    def scalar(self) -> float:\n        \"\"\"Returns the scalar value of the parameter\"\"\"",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Scalar",
        "kind": 6,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "class Scalar(SimParam):\n    \"\"\"A class to represent a scalar value\"\"\"\n    def __init__(self, value: float, unit: str = '', inf: float = np.inf):\n        self._value = value\n        self._inf = inf\n        self.unit = unit\n    def __repr__(self) -> str:\n        return f\"SimValue({self._value})\"\n    def negative(self) -> SimParam:\n        \"\"\"Returns the negative of the scalar\"\"\"",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Negative",
        "kind": 6,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "class Negative(SimParam):\n    \"\"\"A class to represent the negative of a parameter\"\"\"\n    def __init__(self, simparam: SimParam, inf: float = np.inf):\n        self._simparam: SimParam = simparam\n        self.unit = simparam.unit\n        self._inf = inf\n    def __repr__(self) -> str:\n        return f\"Negative({self._simparam})\"\n    def __call__(self, f: np.ndarray) -> np.ndarray:\n        return np.nan_to_num(-self._simparam(f), posinf=self._inf, neginf=-self._inf)",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Inverse",
        "kind": 6,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "class Inverse(SimParam):\n    def __init__(self, simparam: SimParam, inf: float = np.inf):\n        self._simparam: SimParam = simparam\n        self.unit = simparam.unit\n        self._inf = inf\n    def __repr__(self) -> str:\n        return f\"Inverse({self._simparam})\"\n    def __call__(self, f: np.ndarray) -> np.ndarray:\n        return np.nan_to_num(1/self._simparam(f), posinf=self._inf, neginf=-self._inf)\n    def inverse(self) -> SimParam:",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Function",
        "kind": 6,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "class Function(SimParam):\n    def __init__(self, \n                 function: Callable[[np.ndarray], np.ndarray], \n                 unit: str ='',\n                 inf: float = np.inf):\n        \"\"\"A class to represent a function of frequency.\n        Parameters:\n        -----------\n        function : Callable[[np.ndarray], np.ndarray]\n            The function of frequency.",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Random",
        "kind": 6,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "class Random(SimParam):\n    def __init__(self, randomizer: Callable, unit: str = '', inf: float = np.inf):\n        \"\"\"A class to represent a random value.\n        Parameters:\n        -----------\n        randomizer : Callable\n            A function that returns a random value.\n        \"\"\"\n        super().__init__()\n        self._randomizer = randomizer",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Param",
        "kind": 6,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "class Param(SimParam):\n    \"\"\" A class to represent a parameter that is swept over a range of values.\n    Parameters:\n    -----------\n    values : np.ndarray\n        An array of values to sweep over\n    \"\"\"\n    def __init__(self, values: np.ndarray, unit: str = '', inf: float = np.inf):\n        super().__init__()\n        self._values = values",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "ParameterSweep",
        "kind": 6,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "class ParameterSweep:\n    def __init__(self):\n        self.sweep_dimensions: list[tuple[Param]] = []\n        self.index_series: list[tuple[int]] = []\n        self._index: int = 0\n        self._param_buffer: list = []\n        self._S_data: list[np.ndarray] = []\n        self._current_index: tuple[int] = None\n        self._mdim_data: NDSparameters = None\n        self._fdata: np.ndarray = None",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "MonteCarlo",
        "kind": 6,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "class MonteCarlo:\n    \"\"\"A class to represent a Monte Carlo simulation.\"\"\"\n    def __init__(self):\n        self._random_numbers: list[Random] = []\n    def gaussian(self, mean: float, std: float) -> Random:\n        \"\"\"Adds a Gaussian random number to the Monte Carlo simulation.\n        Parameters:\n        -----------\n        mean : float\n            The mean of the Gaussian distribution.",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "format_value_units",
        "kind": 2,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "def format_value_units(value: float, unit: str) -> str:\n    \"\"\" Formats a value with units for display. \"\"\"\n    v, p = _get_power(value)\n    return f\"{v:.2f} {TEN_POWERS[p]}{unit}\"\nclass Uninitialized:\n    \"\"\"A class to represent an uninitialized value\"\"\"\n    def __init__(self):\n        pass\n    def __repr__(self):\n        return \"Uninitialized\"",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "enforce_simparam",
        "kind": 2,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "def enforce_simparam(value: float | SimParam | Callable, inverse: bool = False, unit: str = '') -> SimParam:\n    \"\"\"Parses a numeric value to a SimParam object.\n    Parameters:\n    -----------\n    value : float | Scalar | Callable\n        The value to parse.\n    inverse : bool\n        Whether to return the inverse of the value.\n    Returns:\n    --------",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "ensure_simparam",
        "kind": 2,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "def ensure_simparam(func):\n    # Get the function signature\n    sig = inspect.signature(func)\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        bound_args = sig.bind(*args, **kwargs)\n        bound_args.apply_defaults()\n        # Convert arguments to float if their type hint is complex or float\n        for name, value in bound_args.arguments.items():\n            param = sig.parameters[name]",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "set_print_frequency",
        "kind": 2,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "def set_print_frequency(frequency: float) -> None:\n    \"\"\"Sets the frequency at which the simulation parameters are evaluated for printing.\n    Parameters:\n    -----------\n    frequency : float\n        The frequency at which the simulation parameters are evaluated.\n    \"\"\"\n    # check if frequency is a float with a valid value\n    if not isinstance(frequency, (int, float)):\n        raise ValueError(\"Frequency must be a float\")",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "TEN_POWERS",
        "kind": 5,
        "importPath": "src.heavi.numeric",
        "description": "src.heavi.numeric",
        "peekOfCode": "TEN_POWERS = {\n    -12: \"p\",\n    -9: \"n\",\n    -6: \"u\",\n    -3: \"m\",\n    0: \"\",\n    3: \"k\",\n    6: \"M\",\n    9: \"T\",\n    12: \"P\",",
        "detail": "src.heavi.numeric",
        "documentation": {}
    },
    {
        "label": "Components",
        "kind": 6,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "class Components:\n    RESISTOR = {'name': 'Resistor', 'unit': ''}\n    CAPACITOR = {'name': 'Capacitor', 'unit': 'F'}\n    INDUCTOR = {'name': 'Inductor', 'unit': 'H'}\n    CURRENTSOURCE = {'name': 'Current Source', 'unit': 'A'}\n    VOLTAGESOURCE = {'name': 'Voltage Source', 'unit': 'V'}\n    IMPEDANCE = {'name': 'Impedance', 'unit': ''}\n    ADMITTANCE = {'name': 'Admittance', 'unit': 'G'}\n    TRANSMISSIONLINE = {'name': 'Transmission Line', 'unit': ''}\n    NPORT = {'name': 'N-Port', 'unit': ''}",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "class Node:\n    \"\"\" Node class for the Network object. \"\"\"\n    name: str\n    _index: int = None\n    _parent: Network = None\n    _linked: Node = None\n    _gnd: bool = False\n    def __repr__(self) -> str:\n        if self._gnd:\n            return 'Node[GND]'",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "ComponentFunction",
        "kind": 6,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "class ComponentFunction:\n    \"\"\" ComponentFunction class for the Component object. \"\"\"\n    idx_generators: list[list[Node]]\n    function: SimParam\n    @property\n    def _slice(self):\n        return self.gen_slice()\n    def gen_slice(self):\n        if len(self.idx_generators) == 1:\n            return np.ix_([n.index for n in self.idx_generators[0]])",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Compilable",
        "kind": 6,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "class Compilable:\n    is_linear: bool = False\n    def _get_functions(self, type: Literal['G','B','C','D','I']) -> list[ComponentFunction]:\n        return [f for f in self.functions if f.matrix == type]\n    def _generate_compiler(self, simulation: Literal['SP','DC','AC']) -> Callable:\n        '''Generates a callable that will plug in the components matrix entries for a given frequency.'''\n        if simulation == 'SP':\n            def compiler(matrix: np.ndarray, f: float) -> np.ndarray:\n                for function in self.functions:\n                    matrix[function.gen_slice()] += function.function(f)",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Component",
        "kind": 6,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "class Component(Compilable):\n    \"\"\" Component class for the Network object. \n    This class represents a component in the network, such as a resistor, capacitor, inductor, etc.\n    Parameters\n    ----------\n    nodes : list[Node]\n        A list of Node objects corresponding to the nodes the component is connected to.\n    functions : list[ComponentFunction]\n        A list of ComponentFunction objects corresponding to the functions of the component.\n    source_functions : list[ComponentFunction]",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "LinearComponent",
        "kind": 6,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "class LinearComponent(Component):\n    is_linear: bool = True\nclass NonLinearComponent(Component):\n    is_linear: bool = False\n    def __init__(\n        self, nodes: list[Node], \n        functions: list[ComponentFunction] = None, \n        source_functions: list[ComponentFunction] = None,\n        component_value: SimParam = None,\n        v_function: Callable[[np.ndarray], np.ndarray] = None,",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "NonLinearComponent",
        "kind": 6,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "class NonLinearComponent(Component):\n    is_linear: bool = False\n    def __init__(\n        self, nodes: list[Node], \n        functions: list[ComponentFunction] = None, \n        source_functions: list[ComponentFunction] = None,\n        component_value: SimParam = None,\n        v_function: Callable[[np.ndarray], np.ndarray] = None,\n    ):\n        super().__init__(nodes, functions, source_functions, component_value)",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Source",
        "kind": 6,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "class Source(Compilable):\n    ground: Node\n    source_node: Node\n    output_node: Node = None\n    source_impedance: Component = None\n    small_signal: bool = False\n    dc_voltage: float = None\n    ac_voltage: float = None\n    index: int = None\n    functions: list[ComponentFunction] = None, ",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Network",
        "kind": 6,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "class Network:\n    \"\"\" Network class for the Network object.\n    This class represents a network of components and nodes. It is used to build and analyze circuits.\n    Parameters\n    ----------\n    default_name : str\n        The default name for a node.\n    node_name_counter_start : int\n        The starting index for the node name counter.\n    \"\"\"",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "format_value_units",
        "kind": 2,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "def format_value_units(value: float, unit: str) -> str:\n    \"\"\" Formats a value with units for display. \n    >>> format_value_units(4532, 'Hz')\n    '4.53 kHz'\n    \"\"\"\n    v, p = _get_power(value)\n    return f\"{v:.2f} {TEN_POWERS[p]}{unit}\"\ndef Z0_VSWR(Z0: float, max_vswr: float) -> float:\n    \"\"\"\n    Returns a random real impedance corresponding to a random VSWR between 1",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "Z0_VSWR",
        "kind": 2,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "def Z0_VSWR(Z0: float, max_vswr: float) -> float:\n    \"\"\"\n    Returns a random real impedance corresponding to a random VSWR between 1\n    and max_vswr relative to the reference impedance Z0.\n    Parameters\n    ----------\n    Z0 : float\n        The reference impedance (Ohms).\n    max_vswr : float\n        The maximum possible VSWR.",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "randphase",
        "kind": 2,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "def randphase():\n    \"\"\" Returns a complex number with a random phase. \"\"\"\n    return np.exp(complex(0, 2 * np.pi * np.random.random_sample()))\ndef randmag(minv, maxv):\n    \"\"\" Returns a random number between minv and maxv. \"\"\"\n    return (maxv - minv) * np.random.random_sample() + minv\ndef randomphasor(minv=0, maxv=1):\n    \"\"\" Returns a random complex number with a random phase and magnitude. \"\"\"\n    return randmag(minv, maxv) * randphase()\n@dataclass",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "randmag",
        "kind": 2,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "def randmag(minv, maxv):\n    \"\"\" Returns a random number between minv and maxv. \"\"\"\n    return (maxv - minv) * np.random.random_sample() + minv\ndef randomphasor(minv=0, maxv=1):\n    \"\"\" Returns a random complex number with a random phase and magnitude. \"\"\"\n    return randmag(minv, maxv) * randphase()\n@dataclass\nclass Node:\n    \"\"\" Node class for the Network object. \"\"\"\n    name: str",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "randomphasor",
        "kind": 2,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "def randomphasor(minv=0, maxv=1):\n    \"\"\" Returns a random complex number with a random phase and magnitude. \"\"\"\n    return randmag(minv, maxv) * randphase()\n@dataclass\nclass Node:\n    \"\"\" Node class for the Network object. \"\"\"\n    name: str\n    _index: int = None\n    _parent: Network = None\n    _linked: Node = None",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "TEN_POWERS",
        "kind": 5,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "TEN_POWERS = {\n    -12: \"p\",\n    -9: \"n\",\n    -6: \"u\",\n    -3: \"m\",\n    0: \"\",\n    3: \"k\",\n    6: \"M\",\n    9: \"T\",\n    12: \"P\",",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "_TWO_MAT",
        "kind": 5,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "_TWO_MAT = np.array([[1,-1],[-1,1]])\nclass Components:\n    RESISTOR = {'name': 'Resistor', 'unit': ''}\n    CAPACITOR = {'name': 'Capacitor', 'unit': 'F'}\n    INDUCTOR = {'name': 'Inductor', 'unit': 'H'}\n    CURRENTSOURCE = {'name': 'Current Source', 'unit': 'A'}\n    VOLTAGESOURCE = {'name': 'Voltage Source', 'unit': 'V'}\n    IMPEDANCE = {'name': 'Impedance', 'unit': ''}\n    ADMITTANCE = {'name': 'Admittance', 'unit': 'G'}\n    TRANSMISSIONLINE = {'name': 'Transmission Line', 'unit': ''}",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "TWOPI",
        "kind": 5,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "TWOPI = np.float64(2 * np.pi)\nPI = np.pi\nGEN_NULL = Scalar(0)\nNPZERO = np.float64(0)\ndef randphase():\n    \"\"\" Returns a complex number with a random phase. \"\"\"\n    return np.exp(complex(0, 2 * np.pi * np.random.random_sample()))\ndef randmag(minv, maxv):\n    \"\"\" Returns a random number between minv and maxv. \"\"\"\n    return (maxv - minv) * np.random.random_sample() + minv",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "PI",
        "kind": 5,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "PI = np.pi\nGEN_NULL = Scalar(0)\nNPZERO = np.float64(0)\ndef randphase():\n    \"\"\" Returns a complex number with a random phase. \"\"\"\n    return np.exp(complex(0, 2 * np.pi * np.random.random_sample()))\ndef randmag(minv, maxv):\n    \"\"\" Returns a random number between minv and maxv. \"\"\"\n    return (maxv - minv) * np.random.random_sample() + minv\ndef randomphasor(minv=0, maxv=1):",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "GEN_NULL",
        "kind": 5,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "GEN_NULL = Scalar(0)\nNPZERO = np.float64(0)\ndef randphase():\n    \"\"\" Returns a complex number with a random phase. \"\"\"\n    return np.exp(complex(0, 2 * np.pi * np.random.random_sample()))\ndef randmag(minv, maxv):\n    \"\"\" Returns a random number between minv and maxv. \"\"\"\n    return (maxv - minv) * np.random.random_sample() + minv\ndef randomphasor(minv=0, maxv=1):\n    \"\"\" Returns a random complex number with a random phase and magnitude. \"\"\"",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "NPZERO",
        "kind": 5,
        "importPath": "src.heavi.rfcircuit",
        "description": "src.heavi.rfcircuit",
        "peekOfCode": "NPZERO = np.float64(0)\ndef randphase():\n    \"\"\" Returns a complex number with a random phase. \"\"\"\n    return np.exp(complex(0, 2 * np.pi * np.random.random_sample()))\ndef randmag(minv, maxv):\n    \"\"\" Returns a random number between minv and maxv. \"\"\"\n    return (maxv - minv) * np.random.random_sample() + minv\ndef randomphasor(minv=0, maxv=1):\n    \"\"\" Returns a random complex number with a random phase and magnitude. \"\"\"\n    return randmag(minv, maxv) * randphase()",
        "detail": "src.heavi.rfcircuit",
        "documentation": {}
    },
    {
        "label": "solve_single_frequency_c_compiled",
        "kind": 2,
        "importPath": "src.heavi.solver",
        "description": "src.heavi.solver",
        "peekOfCode": "def solve_single_frequency_c_compiled(Is, Ys, Zs, indices, frequencies, progprox):\n    nT = len(indices)\n    nF = len(frequencies)\n    Ss = np.zeros((nT,nT,nF), dtype=np.complex128)\n    Vdonor = np.zeros((Is.shape[0],), dtype=np.complex128)\n    for it in range(nT):\n        ind1 = indices[it]\n        for i in prange(nF):\n            Vh = 0*Vdonor\n            Vh[1:] = np.linalg.solve(Ys[:,:,i],Is[1:,it,i])",
        "detail": "src.heavi.solver",
        "documentation": {}
    },
    {
        "label": "solve_MNA_RF",
        "kind": 2,
        "importPath": "src.heavi.solver",
        "description": "src.heavi.solver",
        "peekOfCode": "def solve_MNA_RF(As, Zs, port_indices, frequencies, nnodes, nsources, progress_object):\n    \"\"\"\n    Compute the S-parameter matrix for an RF network using Numba for acceleration.\n    Parameters\n    ----------\n    Is : numpy.ndarray\n        Current sources, complex-valued array of shape (n_nodes, n_ports, n_freqs).\n    Ys : numpy.ndarray\n        Admittance matrices, complex-valued array of shape (n_nodes, n_nodes, n_freqs).\n    Zs : numpy.ndarray",
        "detail": "src.heavi.solver",
        "documentation": {}
    },
    {
        "label": "solve_MNA_DC",
        "kind": 2,
        "importPath": "src.heavi.solver",
        "description": "src.heavi.solver",
        "peekOfCode": "def solve_MNA_DC(As, SolutionVector, nnodes, nsources):\n    \"\"\"\n    Compute the S-parameter matrix for an RF network using Numba for acceleration.\n    Parameters\n    ----------\n    Is : numpy.ndarray\n        Current sources, complex-valued array of shape (n_nodes, n_ports, n_freqs).\n    Ys : numpy.ndarray\n        Admittance matrices, complex-valued array of shape (n_nodes, n_nodes, n_freqs).\n    Zs : numpy.ndarray",
        "detail": "src.heavi.solver",
        "documentation": {}
    },
    {
        "label": "solve_MNA_RF_nopgb",
        "kind": 2,
        "importPath": "src.heavi.solver",
        "description": "src.heavi.solver",
        "peekOfCode": "def solve_MNA_RF_nopgb(As, Zs, port_indices, frequencies, nnodes, nsources):\n    \"\"\"\n    Compute the S-parameter matrix for an RF network using Numba for acceleration.\n    Parameters\n    ----------\n    Is : numpy.ndarray\n        Current sources, complex-valued array of shape (n_nodes, n_ports, n_freqs).\n    Ys : numpy.ndarray\n        Admittance matrices, complex-valued array of shape (n_nodes, n_nodes, n_freqs).\n    Zs : numpy.ndarray",
        "detail": "src.heavi.solver",
        "documentation": {}
    },
    {
        "label": "compute_s_parameters",
        "kind": 2,
        "importPath": "src.heavi.solver",
        "description": "src.heavi.solver",
        "peekOfCode": "def compute_s_parameters(Is, Ys, Zs, port_indices, frequencies, progress_object):\n    \"\"\"\n    Compute the S-parameter matrix for an RF network using Numba for acceleration.\n    Parameters\n    ----------\n    Is : numpy.ndarray\n        Current sources, complex-valued array of shape (n_nodes, n_ports, n_freqs).\n    Ys : numpy.ndarray\n        Admittance matrices, complex-valued array of shape (n_nodes, n_nodes, n_freqs).\n    Zs : numpy.ndarray",
        "detail": "src.heavi.solver",
        "documentation": {}
    },
    {
        "label": "compute_s_parameters_no_loadbar",
        "kind": 2,
        "importPath": "src.heavi.solver",
        "description": "src.heavi.solver",
        "peekOfCode": "def compute_s_parameters_no_loadbar(Is, Ys, Zs, port_indices, frequencies):\n    \"\"\"\n    Compute the S-parameter matrix for an RF network using Numba for acceleration.\n    Parameters\n    ----------\n    Is : numpy.ndarray\n        Current sources, complex-valued array of shape (n_nodes, n_ports, n_freqs).\n    Ys : numpy.ndarray\n        Admittance matrices, complex-valued array of shape (n_nodes, n_nodes, n_freqs).\n    Zs : numpy.ndarray",
        "detail": "src.heavi.solver",
        "documentation": {}
    },
    {
        "label": "Sparameters",
        "kind": 6,
        "importPath": "src.heavi.sparam",
        "description": "src.heavi.sparam",
        "peekOfCode": "class Sparameters:\n    def __init__(self, S: np.ndarray, f: np.ndarray):\n        \"\"\" S-parameters object\n        Parameters\n        ----------\n        S : np.ndarray\n            Scattering matrix of shape (nports, nports, nfreqs) \n        s\"\"\"\n        self._S: np.ndarray = S\n        self.f: float = f",
        "detail": "src.heavi.sparam",
        "documentation": {}
    },
    {
        "label": "Interpolator",
        "kind": 6,
        "importPath": "src.heavi.sparam",
        "description": "src.heavi.sparam",
        "peekOfCode": "class Interpolator:\n    def __init__(self, interp: RegularGridInterpolator):\n        self._interp: RegularGridInterpolator = interp\n    def __call__(self, *args):\n        return np.squeeze(self._interp(np.meshgrid(*args, indexing='ij')))\nclass NDSparameters(Sparameters):\n    def __init__(self, mdim_data: np.ndarray, axes: list[np.ndarray]):\n        self._sdata: np.ndarray = mdim_data\n        self._axes: list[np.ndarray] = axes\n        self._shape: tuple[int] = self._sdata.shape",
        "detail": "src.heavi.sparam",
        "documentation": {}
    },
    {
        "label": "NDSparameters",
        "kind": 6,
        "importPath": "src.heavi.sparam",
        "description": "src.heavi.sparam",
        "peekOfCode": "class NDSparameters(Sparameters):\n    def __init__(self, mdim_data: np.ndarray, axes: list[np.ndarray]):\n        self._sdata: np.ndarray = mdim_data\n        self._axes: list[np.ndarray] = axes\n        self._shape: tuple[int] = self._sdata.shape\n        self._extra_dims: int = len(self._shape) - 3\n        self.nports: int = self._shape[-2]\n        self.nfreqs: int = self._shape[-1]\n    @property\n    def _outer_axes(self) -> tuple:",
        "detail": "src.heavi.sparam",
        "documentation": {}
    },
    {
        "label": "frange",
        "kind": 2,
        "importPath": "src.heavi.sparam",
        "description": "src.heavi.sparam",
        "peekOfCode": "def frange(fmin: float, fmax: float, n: int) -> np.ndarray:\n    \"\"\"Generate n frequencies from fmin to fmax\"\"\"\n    return np.linspace(fmin, fmax, n)\nclass Sparameters:\n    def __init__(self, S: np.ndarray, f: np.ndarray):\n        \"\"\" S-parameters object\n        Parameters\n        ----------\n        S : np.ndarray\n            Scattering matrix of shape (nports, nports, nfreqs) ",
        "detail": "src.heavi.sparam",
        "documentation": {}
    },
    {
        "label": "analyse_sparameter",
        "kind": 2,
        "importPath": "src.heavi.stochastic",
        "description": "src.heavi.stochastic",
        "peekOfCode": "def analyse_sparameter(sparam: list[np.ndarray], sparam_phase: list[np.ndarray], phase_reference: np.ndarray=None, n_bins: int = 51) -> tuple[tuple[float, float], tuple[float, float]]:\n    \"\"\"\n    Analyse a set of S-parameter arrays, returning amplitude (dB) and phase statistics\n    and plotting their histograms (PDF) and cumulative distributions (CDF), each on a\n    separate y-axis.\n    Parameters\n    ----------\n    sparam : list of np.ndarray\n        Each element is a complex-valued S-parameter array (e.g. shape (F,)).\n        We flatten them over frequency.",
        "detail": "src.heavi.stochastic",
        "documentation": {}
    },
    {
        "label": "S11_to_VSWR",
        "kind": 2,
        "importPath": "src.heavi.transformations",
        "description": "src.heavi.transformations",
        "peekOfCode": "def S11_to_VSWR(S11: np.ndarray) -> np.ndarray:\n    \"\"\"Convert S11 to VSWR\"\"\"\n    return (1 + np.abs(S11)) / (1 - np.abs(S11))\ndef S11_to_impedance(S11: np.ndarray, Z0: float = 50) -> np.ndarray:\n    \"\"\"Convert S11 to impedance\"\"\"\n    return Z0 * (1 + S11) / (1 - S11)\ndef Z_to_S11(Z: np.ndarray, Z0: float = 50) -> np.ndarray:\n    \"\"\"Convert impedance to S11\"\"\"\n    return (Z - Z0) / (Z + Z0)\ndef VSWR_to_S11(VSWR: np.ndarray) -> np.ndarray:",
        "detail": "src.heavi.transformations",
        "documentation": {}
    },
    {
        "label": "S11_to_impedance",
        "kind": 2,
        "importPath": "src.heavi.transformations",
        "description": "src.heavi.transformations",
        "peekOfCode": "def S11_to_impedance(S11: np.ndarray, Z0: float = 50) -> np.ndarray:\n    \"\"\"Convert S11 to impedance\"\"\"\n    return Z0 * (1 + S11) / (1 - S11)\ndef Z_to_S11(Z: np.ndarray, Z0: float = 50) -> np.ndarray:\n    \"\"\"Convert impedance to S11\"\"\"\n    return (Z - Z0) / (Z + Z0)\ndef VSWR_to_S11(VSWR: np.ndarray) -> np.ndarray:\n    \"\"\"Convert VSWR to S11\"\"\"\n    return (VSWR - 1) / (VSWR + 1)",
        "detail": "src.heavi.transformations",
        "documentation": {}
    },
    {
        "label": "Z_to_S11",
        "kind": 2,
        "importPath": "src.heavi.transformations",
        "description": "src.heavi.transformations",
        "peekOfCode": "def Z_to_S11(Z: np.ndarray, Z0: float = 50) -> np.ndarray:\n    \"\"\"Convert impedance to S11\"\"\"\n    return (Z - Z0) / (Z + Z0)\ndef VSWR_to_S11(VSWR: np.ndarray) -> np.ndarray:\n    \"\"\"Convert VSWR to S11\"\"\"\n    return (VSWR - 1) / (VSWR + 1)",
        "detail": "src.heavi.transformations",
        "documentation": {}
    },
    {
        "label": "VSWR_to_S11",
        "kind": 2,
        "importPath": "src.heavi.transformations",
        "description": "src.heavi.transformations",
        "peekOfCode": "def VSWR_to_S11(VSWR: np.ndarray) -> np.ndarray:\n    \"\"\"Convert VSWR to S11\"\"\"\n    return (VSWR - 1) / (VSWR + 1)",
        "detail": "src.heavi.transformations",
        "documentation": {}
    }
]